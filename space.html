<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Galactic Observatory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: black;
      font-family: sans-serif;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color3.Black();
const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI/2, Math.PI/2.2, 250, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);

const light = new BABYLON.PointLight("SunLight", new BABYLON.Vector3(0, 0, 0), scene);
light.intensity = 2.5;

// Starfield Background
const backgroundLayer = new BABYLON.Layer("starfield", "8k_stars_milky_way.jpg", scene, true);const sun = BABYLON.MeshBuilder.CreateSphere("Sun", { diameter: 18 }, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveColor = new BABYLON.Color3(1, 0.85, 0.2);
sun.material = sunMat;

// Add rotating sunspots using dynamic texture (simplified representation)
const sunTexture = new BABYLON.DynamicTexture("sunSpots", {width:512, height:512}, scene, false);
const ctx = sunTexture.getContext();
ctx.fillStyle = "rgb(255,220,100)";
ctx.fillRect(0, 0, 512, 512);
ctx.fillStyle = "rgba(0,0,0,0.3)";
for (let i = 0; i < 5; i++) {
  const x = Math.random() * 512;
  const y = Math.random() * 512;
  ctx.beginPath();
  ctx.arc(x, y, 20 + Math.random() * 10, 0, 2 * Math.PI);
  ctx.fill();
}
sunTexture.update();
sunMat.diffuseTexture = sunTexture;

// Add glow
const gl = new BABYLON.GlowLayer("glow", scene);
function createPlanet(name, size, distance, speed, color, moons = []) {
  const planet = BABYLON.MeshBuilder.CreateSphere(name, { diameter: size }, scene);
  const mat = new BABYLON.StandardMaterial(`${name}_mat`, scene);
  mat.diffuseColor = color;
  planet.material = mat;

  let angle = Math.random() * Math.PI * 2;
  scene.registerBeforeRender(() => {
    angle += speed;
    planet.position.x = Math.cos(angle) * distance;
    planet.position.z = Math.sin(angle) * distance;
  });

  moons.forEach((moon, i) => {
    const m = BABYLON.MeshBuilder.CreateSphere(`${name}_moon_${i}`, { diameter: moon.size }, scene);
    const moonMat = new BABYLON.StandardMaterial(`moonMat_${i}`, scene);
    moonMat.diffuseColor = moon.color;
    m.material = moonMat;

    let mAngle = Math.random() * Math.PI * 2;
    scene.registerBeforeRender(() => {
      mAngle += moon.speed;
      m.position.x = planet.position.x + Math.cos(mAngle) * moon.distance;
      m.position.z = planet.position.z + Math.sin(mAngle) * moon.distance;
      m.position.y = planet.position.y;
    });
  });

  return planet;
}
const planets = [
  { name: "Mercury", size: 1.5, dist: 25, speed: 0.018, color: new BABYLON.Color3(0.6,0.6,0.6), moons: [] },
  { name: "Venus",   size: 2.8, dist: 35, speed: 0.014, color: new BABYLON.Color3(0.9,0.7,0.4), moons: [] },
  { name: "Earth",   size: 3.0, dist: 50, speed: 0.012, color: new BABYLON.Color3(0.2,0.6,1.0), moons: [
    { size: 1, distance: 4, speed: 0.05, color: new BABYLON.Color3.White() }
  ]},
  { name: "Mars",    size: 2.0, dist: 65, speed: 0.010, color: new BABYLON.Color3(0.9,0.3,0.2), moons: [
    { size: 0.6, distance: 2, speed: 0.07, color: new BABYLON.Color3.Gray() },
    { size: 0.4, distance: 3, speed: 0.08, color: new BABYLON.Color3.Gray() }
  ]},
  { name: "Jupiter", size: 6.0, dist: 90, speed: 0.007, color: new BABYLON.Color3(0.9,0.8,0.6), moons: [
    { size: 1.2, distance: 7, speed: 0.03, color: new BABYLON.Color3(1,1,0.9) },
    { size: 1.2, distance: 9, speed: 0.028, color: new BABYLON.Color3(0.6,0.7,1) },
    { size: 1.4, distance: 11, speed: 0.025, color: new BABYLON.Color3(1,0.9,0.7) },
    { size: 1.3, distance: 13, speed: 0.022, color: new BABYLON.Color3(1,0.8,0.6) }
  ]},
  { name: "Saturn",  size: 5.5, dist: 115, speed: 0.005, color: new BABYLON.Color3(0.95,0.85,0.5), moons: [] },
  { name: "Uranus",  size: 4.5, dist: 140, speed: 0.004, color: new BABYLON.Color3(0.5,0.9,1.0), moons: [] },
  { name: "Neptune", size: 4.3, dist: 160, speed: 0.0035, color: new BABYLON.Color3(0.3,0.5,1.0), moons: [] },
  { name: "Pluto",   size: 1.5, dist: 180, speed: 0.002, color: new BABYLON.Color3(0.8,0.8,0.8), moons: [
    { size: 0.8, distance: 2.5, speed: 0.03, color: new BABYLON.Color3(0.9,0.9,1.0) }
  ]}
];

planets.forEach(p => createPlanet(p.name, p.size, p.dist, p.speed, p.color, p.moons));
function createOrbit(radius) {
  const points = [];
  for (let i = 0; i <= 360; i++) {
    const angle = BABYLON.Tools.ToRadians(i);
    points.push(new BABYLON.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius));
  }
  const orbit = BABYLON.MeshBuilder.CreateLines("orbit", { points: points }, scene);
  orbit.color = new BABYLON.Color3(1, 1, 1);
  orbit.alpha = 0.05;
}
planets.forEach(p => createOrbit(p.dist));
const majorStars = [
  { name: "Sirius", color: new BABYLON.Color3(0.6,0.8,1.0), pos: new BABYLON.Vector3(-500, 80, 200) },
  { name: "Betelgeuse", color: new BABYLON.Color3(1.0,0.6,0.2), pos: new BABYLON.Vector3(400, 90, -250) },
  { name: "Rigel", color: new BABYLON.Color3(0.7,0.8,1.0), pos: new BABYLON.Vector3(-600, 120, -300) },
  { name: "Vega", color: new BABYLON.Color3(0.8,0.9,1.0), pos: new BABYLON.Vector3(150, 350, 0) },
  { name: "Polaris", color: new BABYLON.Color3(1.0,1.0,0.85), pos: new BABYLON.Vector3(0, 500, 0) },
  { name: "Alpha Centauri", color: new BABYLON.Color3(1.0,0.9,0.7), pos: new BABYLON.Vector3(-100, -50, 300) }
];

majorStars.forEach(star => {
  const s = BABYLON.MeshBuilder.CreateSphere(star.name, { diameter: 4 }, scene);
  s.position = star.pos;
  const mat = new BABYLON.StandardMaterial(star.name + "_mat", scene);
  mat.emissiveColor = star.color;
  s.material = mat;
});
let gridLines = null;
function createGalacticGrid() {
  const size = 300, step = 30;
  const lines = [];

  for (let i = -size; i <= size; i += step) {
    lines.push([
      new BABYLON.Vector3(i, 0, -size),
      new BABYLON.Vector3(i, 0, size)
    ]);
    lines.push([
      new BABYLON.Vector3(-size, 0, i),
      new BABYLON.Vector3(size, 0, i)
    ]);
  }

  gridLines = BABYLON.MeshBuilder.CreateLineSystem("grid", { lines }, scene);
  gridLines.color = new BABYLON.Color3(1,1,1);
  gridLines.alpha = 0.03;
  gridLines.isVisible = false;
}
createGalacticGrid();
const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

const panel = new BABYLON.GUI.Rectangle();
panel.width = "240px";
panel.height = "auto";
panel.thickness = 0;
panel.cornerRadius = 10;
panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
panel.paddingTop = "10px";
panel.paddingLeft = "10px";
panel.background = window.matchMedia("(prefers-color-scheme: dark)").matches ? "rgba(30,30,30,0.6)" : "rgba(255,255,255,0.6)";
gui.addControl(panel);

const stack = new BABYLON.GUI.StackPanel();
stack.width = "100%";
panel.addControl(stack);

function addButton(text, callback) {
  const btn = BABYLON.GUI.Button.CreateSimpleButton(text, text);
  btn.width = "100%";
  btn.height = "30px";
  btn.color = window.matchMedia("(prefers-color-scheme: dark)").matches ? "white" : "black";
  btn.background = "transparent";
  btn.paddingBottom = "6px";
  btn.onPointerClickObservable.add(callback);
  stack.addControl(btn);
  return btn;
}

// Add buttons
let gridShown = false;
const gridBtn = addButton("Show Grid", () => {
  gridShown = !gridShown;
  if (gridLines) gridLines.isVisible = gridShown;
  gridBtn.textBlock.text = gridShown ? "Hide Grid" : "Show Grid";
});

addButton("Simulate Solar Eclipse", () => { /* Your solar eclipse logic here */ });
addButton("Simulate Lunar Eclipse", () => { /* Your lunar eclipse logic here */ });
addButton("Show Current Positions", () => { /* Align planet positions */ });
addButton("Start Camera Tour", () => { /* Animate camera path */ });
window.addEventListener("keydown", e => {
  if (e.key === "f" || e.key === "F") {
    if (!document.fullscreenElement) {
      canvas.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  }
});
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>
</body>
</html>