<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar Observatory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="favicon.ico" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: black;
      font-family: 'Segoe UI', sans-serif;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #splash-screen {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background-color: black;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #splash-screen img {
      max-width: 80%;
      opacity: 0.8;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <div id="splash-screen">
    <img src="splash-loading-screen.png" alt="Loading..." />
  </div>
  <canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color3.Black();

const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.2, 2500, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 20;
camera.upperRadiusLimit = 10000;

const light = new BABYLON.PointLight("SunLight", BABYLON.Vector3.Zero(), scene);
light.intensity = 2.5;

const glowLayer = new BABYLON.GlowLayer("glow", scene);
const starfield = new BABYLON.Layer("starfield", "8k_stars_milky_way.jpg", scene, true);

let timeFactor = 1;
let followPlanet = null;
</script>
<script>
const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

const panel = new BABYLON.GUI.Rectangle();
panel.width = "250px";
panel.background = "rgba(20,20,20,0.85)";
panel.cornerRadius = 8;
panel.thickness = 0;
panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
gui.addControl(panel);

const stack = new BABYLON.GUI.StackPanel();
panel.addControl(stack);

// GUI helper: Add a labeled button with a callback
function addButton(label, callback) {
  const btn = BABYLON.GUI.Button.CreateSimpleButton("btn_" + label, label);
  btn.height = "30px";
  btn.width = "100%";
  btn.color = "lightgreen";
  btn.background = "transparent";
  btn.onPointerClickObservable.add(callback);
  stack.addControl(btn);
}
</script>
<script>
const planetsData = [
  { name: "Mercury", distance: 80, speed: 4.8, size: 4, color: new BABYLON.Color3(0.5, 0.5, 0.5) },
  { name: "Venus", distance: 120, speed: 3.5, size: 5.5, color: new BABYLON.Color3(0.9, 0.7, 0.3) },
  { name: "Earth", distance: 160, speed: 2.98, size: 6, color: new BABYLON.Color3(0.4, 0.6, 1) },
  { name: "Mars", distance: 210, speed: 2.4, size: 5, color: new BABYLON.Color3(1, 0.4, 0.3) },
  { name: "Jupiter", distance: 280, speed: 1.3, size: 12, color: new BABYLON.Color3(0.8, 0.6, 0.4) },
  { name: "Saturn", distance: 360, speed: 0.96, size: 10, color: new BABYLON.Color3(1, 0.9, 0.6) },
  { name: "Uranus", distance: 430, speed: 0.68, size: 8, color: new BABYLON.Color3(0.6, 0.9, 1) },
  { name: "Neptune", distance: 490, speed: 0.54, size: 8, color: new BABYLON.Color3(0.3, 0.4, 1) },
  { name: "Pluto", distance: 560, speed: 0.47, size: 2.5, color: new BABYLON.Color3(0.8, 0.8, 0.8) }
];

planetsData.forEach(p => {
  const mesh = BABYLON.MeshBuilder.CreateSphere(p.name, { diameter: p.size }, scene);
  const mat = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
  mat.diffuseColor = p.color;
  mesh.material = mat;

  // Animate orbit
  scene.registerBeforeRender(() => {
    const angle = performance.now() * 0.00001 * p.speed * timeFactor;
    mesh.position.x = Math.cos(angle) * p.distance;
    mesh.position.z = Math.sin(angle) * p.distance;
    mesh.position.y = 0;
  });

  // Saturn's rings
  if (p.name === "Saturn") {
    const ring = BABYLON.MeshBuilder.CreateDisc("SaturnRing", {
      radius: p.size * 2,
      tessellation: 64,
      arc: 1
    }, scene);
    const ringMat = new BABYLON.StandardMaterial("SaturnRingMat", scene);
    ringMat.diffuseColor = new BABYLON.Color3(0.8, 0.7, 0.5);
    ringMat.alpha = 0.4;
    ring.material = ringMat;
    ring.rotation.x = Math.PI / 3;
    ring.parent = mesh;
  }
});
</script>
<script>
planetsData.forEach(p => {
  const orbit = BABYLON.MeshBuilder.CreateTorus(`${p.name}_orbit`, {
    diameter: p.distance * 2,
    thickness: 0.15,
    tessellation: 100
  }, scene);

  const orbitMat = new BABYLON.StandardMaterial(`${p.name}_orbit_mat`, scene);
  orbitMat.emissiveColor = new BABYLON.Color3(0.2, 0.6, 0.8);
  orbit.material = orbitMat;
  orbit.rotation.x = Math.PI / 2;
});
</script>
<script>
const asteroidCount = 300;
for (let i = 0; i < asteroidCount; i++) {
  const angle = Math.random() * Math.PI * 2;
  const radius = 260 + Math.random() * 60;
  const height = (Math.random() - 0.5) * 8;

  const rock = BABYLON.MeshBuilder.CreateSphere(`asteroid_${i}`, { diameter: 0.8 }, scene);
  const mat = new BABYLON.StandardMaterial(`asteroidMat_${i}`, scene);
  mat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.3);
  rock.material = mat;

  rock.position.set(
    Math.cos(angle) * radius,
    height,
    Math.sin(angle) * radius
  );
}
</script>
<script>
const comet = BABYLON.MeshBuilder.CreateSphere("Comet", { diameter: 2 }, scene);
const cometMat = new BABYLON.StandardMaterial("cometMat", scene);
cometMat.emissiveColor = new BABYLON.Color3(0.9, 0.9, 1);
comet.material = cometMat;

const cometTrail = new BABYLON.TrailMesh("cometTrail", comet, scene, 60, 1.2, true);
const trailMat = new BABYLON.StandardMaterial("cometTrailMat", scene);
trailMat.emissiveColor = new BABYLON.Color3(0.5, 0.8, 1);
cometTrail.material = trailMat;

scene.registerBeforeRender(() => {
  const t = performance.now() * 0.00002 * timeFactor;
  comet.position.x = Math.sin(t) * 700;
  comet.position.z = Math.cos(t * 0.8) * 500;
  comet.position.y = Math.sin(t * 0.5) * 80;
});
</script>
<script>
const stellarSystems = [
  {
    name: "Proxima Centauri",
    pos: new BABYLON.Vector3(-5000, 0, 9000),
    color: new BABYLON.Color3(1, 0.5, 0.5),
    planets: [{ name: "Proxima b", dist: 40, size: 3, speed: 0.5 }]
  },
  {
    name: "Alpha Centauri",
    pos: new BABYLON.Vector3(8000, 0, -6000),
    color: new BABYLON.Color3(1, 1, 0.7),
    planets: []
  },
  {
    name: "Kepler-186",
    pos: new BABYLON.Vector3(12000, 0, 12000),
    color: new BABYLON.Color3(0.7, 0.9, 1),
    planets: [{ name: "Kepler-186f", dist: 30, size: 2.8, speed: 0.6 }]
  }
];

// Render distant stars and orbiting exoplanets
stellarSystems.forEach(sys => {
  const star = BABYLON.MeshBuilder.CreateSphere(`${sys.name}_star`, { diameter: 20 }, scene);
  const mat = new BABYLON.StandardMaterial(`${sys.name}_mat`, scene);
  mat.emissiveColor = sys.color;
  star.material = mat;
  star.position = sys.pos;

  sys.planets.forEach((p, i) => {
    const planet = BABYLON.MeshBuilder.CreateSphere(`${sys.name}_${p.name}`, { diameter: p.size }, scene);
    const pm = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
    pm.diffuseColor = BABYLON.Color3.Random();
    planet.material = pm;

    scene.registerBeforeRender(() => {
      const angle = performance.now() * 0.00001 * p.speed * timeFactor + i;
      planet.position.x = sys.pos.x + Math.cos(angle) * p.dist;
      planet.position.z = sys.pos.z + Math.sin(angle) * p.dist;
      planet.position.y = sys.pos.y;
    });
  });
});
</script>
<script>
const copilotFacts = [
  "Neptune's winds can hit 1,200 mph.",
  "Pluto's heart-shaped region is called Tombaugh Regio.",
  "Kepler-186f orbits in the habitable zone of its star.",
  "Voyager 1 is still transmitting data over 14 billion miles away.",
  "Jupiter’s magnetic field is 20,000 times stronger than Earth’s."
];

function showCopilotFact() {
  const msg = copilotFacts[Math.floor(Math.random() * copilotFacts.length)];
  const bubble = new BABYLON.GUI.Rectangle("copilotBubble");
  bubble.width = "300px";
  bubble.height = "80px";
  bubble.cornerRadius = 10;
  bubble.color = "white";
  bubble.thickness = 1;
  bubble.background = "rgba(0,0,0,0.85)";
  bubble.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
  bubble.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
  bubble.top = "20px";
  bubble.right = "20px";

  const text = new BABYLON.GUI.TextBlock();
  text.text = msg;
  text.color = "#A0E0FF";
  text.fontSize = 14;
  text.textWrapping = true;
  bubble.addControl(text);
  gui.addControl(bubble);

  if (window.speechSynthesis) {
    const utter = new SpeechSynthesisUtterance(msg);
    utter.lang = "en-US";
    speechSynthesis.speak(utter);
  }

  setTimeout(() => gui.removeControl(bubble), 7000);
}

// Trigger tooltip every ~3 minutes
setInterval(showCopilotFact, 180000);
</script>
<script>
function triggerMeteorShower() {
  const meteors = [];
  for (let i = 0; i < 40; i++) {
    const m = BABYLON.MeshBuilder.CreateSphere(`meteor_${i}`, { diameter: 0.4 }, scene);
    const mat = new BABYLON.StandardMaterial(`meteorMat_${i}`, scene);
    mat.emissiveColor = new BABYLON.Color3(1, 0.5, 0.2);
    mat.alpha = 0.6;
    m.material = mat;

    const start = new BABYLON.Vector3(
      Math.random() * 800 - 400,
      150 + Math.random() * 100,
      Math.random() * 800 - 400
    );
    m.position = start;

    const direction = new BABYLON.Vector3(-1, -1.2, 0).normalize().scale(3 + Math.random() * 2);
    meteors.push({ mesh: m, dir: direction, age: 0 });
  }

  scene.registerBeforeRender(() => {
    meteors.forEach(m => {
      if (m.mesh) {
        m.mesh.position.addInPlace(m.dir);
        m.age++;
        if (m.age > 100) {
          m.mesh.dispose();
          m.mesh = null;
        }
      }
    });
  });
}

// Trigger automatically during Perseids week
const today = new Date();
if (today.getMonth() === 7 && today.getDate() >= 10 && today.getDate() <= 15) {
  triggerMeteorShower();
  if (window.speechSynthesis) {
    const msg = "Perseid meteor shower active this week.";
    speechSynthesis.speak(new SpeechSynthesisUtterance(msg));
  }
}
</script>
<script>
function fetchLaunches() {
  fetch("https://ll.thespacedevs.com/2.2.0/launch/upcoming/?limit=3")
    .then(res => res.json())
    .then(data => {
      const launches = data.results.map(l =>
        `${l.name} — ${new Date(l.window_start).toLocaleString()}`
      ).join("\n");

      // 🛰️ Background panel
      const launchPanel = new BABYLON.GUI.Rectangle();
      launchPanel.width = "300px";
      launchPanel.height = "130px";
      launchPanel.cornerRadius = 10;
      launchPanel.color = "white";
      launchPanel.thickness = 1;
      launchPanel.background = "rgba(10,10,20,0.85)";
      launchPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
      launchPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
      launchPanel.top = "20px";
      launchPanel.left = "20px";
      gui.addControl(launchPanel);

      // 🚀 Launch text block inside panel
      const launchBox = new BABYLON.GUI.TextBlock();
      launchBox.text = "🚀 Upcoming Launches:\n" + launches;
      launchBox.color = "white";
      launchBox.fontSize = 14;
      launchBox.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
      launchBox.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
      launchBox.textWrapping = true;
      launchBox.paddingTop = 8;
      launchBox.paddingLeft = 8;
      launchPanel.addControl(launchBox);

      if (window.speechSynthesis) {
        const msg = new SpeechSynthesisUtterance("Upcoming launches displayed at top left.");
        msg.lang = "en-US";
        speechSynthesis.speak(msg);
      }
    }).catch(err => {
      console.warn("Launch API failed:", err);
    });
}

fetchLaunches();
</script>
<script>
const speedHUD = new BABYLON.GUI.TextBlock();
speedHUD.text = "";
speedHUD.color = "lightgreen";
speedHUD.fontSize = 16;
speedHUD.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
speedHUD.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
speedHUD.top = "50px";
gui.addControl(speedHUD);

scene.registerBeforeRender(() => {
  const speed = Math.abs(timeFactor);
  if (speed >= 1000) {
    const dilation = 1 / Math.sqrt(1 - Math.pow(speed / 299792, 2));
    speedHUD.text = `⏳ Time Dilation: 1s here ≈ ${dilation.toFixed(2)}s on Earth`;
  } else {
    speedHUD.text = "";
  }
});
</script>
<script>
// Focus logic
function focusOnPlanet(name) {
  const target = scene.getMeshByName(name);
  if (!target) return;
  followPlanet = target;

  const animTarget = new BABYLON.Animation("camFocus", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
  animTarget.setKeys([
    { frame: 0, value: camera.target.clone() },
    { frame: 90, value: target.position.clone() }
  ]);

  const animZoom = new BABYLON.Animation("camZoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
  animZoom.setKeys([
    { frame: 0, value: camera.radius },
    { frame: 90, value: 60 }
  ]);

  camera.animations = [animTarget, animZoom];
  scene.beginAnimation(camera, 0, 90, false);
}

scene.onBeforeRenderObservable.add(() => {
  if (followPlanet && followPlanet.position) {
    camera.setTarget(followPlanet.position.clone());
  }
});

// Add planet selection menu
const planetPanel = new BABYLON.GUI.StackPanel();
planetPanel.isVisible = false;
gui.addControl(planetPanel);

addButton("🔭 Select Planet", () => {
  planetPanel.clearControls();
  planetsData.forEach(p => {
    const btn = BABYLON.GUI.Button.CreateSimpleButton(`btn_${p.name}`, p.name);
    btn.height = "30px";
    btn.color = "lightblue";
    btn.background = "rgba(30,30,30,0.7)";
    btn.onPointerClickObservable.add(() => focusOnPlanet(p.name));
    planetPanel.addControl(btn);
  });
  planetPanel.isVisible = !planetPanel.isVisible;
});

// Zoom-out on [Z]
window.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "z") {
    camera.radius *= 1.5;
    followPlanet = null;
  }
});
</script>
<script>
const moon = scene.getMeshByName("Moon") || scene.getMeshByName("Earth"); // fallback if no separate Moon

const landingSites = [
  { name: "Apollo 11", lat: 0.674, lon: 23.472 },
  { name: "Apollo 12", lat: -3.012, lon: -23.421 },
  { name: "Apollo 17", lat: 20.1908, lon: 30.7717 }
];

landingSites.forEach(site => {
  const latRad = BABYLON.Tools.ToRadians(site.lat);
  const lonRad = BABYLON.Tools.ToRadians(site.lon);
  const r = moon.getBoundingInfo().boundingSphere.radius * 1.02;

  const x = r * Math.cos(latRad) * Math.cos(lonRad);
  const y = r * Math.sin(latRad);
  const z = r * Math.cos(latRad) * Math.sin(lonRad);

  const flag = BABYLON.MeshBuilder.CreateBox(site.name, { size: 1 }, scene);
  const flagMat = new BABYLON.StandardMaterial(`${site.name}_mat`, scene);
  flagMat.emissiveColor = new BABYLON.Color3(1, 0.2, 0.2);
  flag.material = flagMat;
  flag.position.set(x, y, z);
  flag.parent = moon;

  flag.actionManager = new BABYLON.ActionManager(scene);
  flag.actionManager.registerAction(
    new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
      const msg = `${site.name} landing site. Welcome to history.`;
      if (window.speechSynthesis) speechSynthesis.speak(new SpeechSynthesisUtterance(msg));
    })
  );
});
</script>
<script>
const surfaceTextures = {
  Earth: "earth_topo_map.jpg",
  Mars: "mars_topo_map.jpg",
  Moon: "moon_map.jpg"
};

addButton("🗺 Surface Maps", () => {
  ["Earth", "Mars", "Moon"].forEach(name => {
    const planet = scene.getMeshByName(name);
    if (planet) {
      const mat = new BABYLON.StandardMaterial(`${name}_surf`, scene);
      mat.diffuseTexture = new BABYLON.Texture(surfaceTextures[name], scene);
      mat.specularColor = BABYLON.Color3.Black();
      planet.material = mat;
    }
  });
});
</script>
<script>
const tourSequence = [...planetsData.map(p => p.name), ...stellarSystems.map(s => s.name)];
let tourIndex = 0;

function startCinematicTour() {
  if (tourIndex >= tourSequence.length) tourIndex = 0;
  const name = tourSequence[tourIndex++];
  const obj = scene.getMeshByName(name);
  if (!obj) return;

  followPlanet = null;
  const animTarget = new BABYLON.Animation("tourTarget", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
  animTarget.setKeys([
    { frame: 0, value: camera.target.clone() },
    { frame: 90, value: obj.position.clone() }
  ]);

  const animZoom = new BABYLON.Animation("tourZoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
  animZoom.setKeys([
    { frame: 0, value: camera.radius },
    { frame: 90, value: 100 }
  ]);

  camera.animations = [animTarget, animZoom];
  scene.beginAnimation(camera, 0, 90, false);
  if (window.speechSynthesis) {
    speechSynthesis.speak(new SpeechSynthesisUtterance(`Now approaching ${name}`));
  }

  setTimeout(startCinematicTour, 7000);
}

addButton("🎥 Start Tour", startCinematicTour);
</script>
<script>
let isRecording = false;
const frames = [];

addButton("⏺ Start Recording", () => {
  isRecording = true;
  frames.length = 0;
  if (window.speechSynthesis) speechSynthesis.speak(new SpeechSynthesisUtterance("Time-lapse recording started."));
});

addButton("⏹ Stop & Download", () => {
  isRecording = false;
  if (window.speechSynthesis) speechSynthesis.speak(new SpeechSynthesisUtterance("Recording complete. Exporting frames."));
  frames.forEach((data, i) => {
    const a = document.createElement("a");
    a.href = data;
    a.download = `frame_${i}.png`;
    a.click();
  });
});

scene.registerAfterRender(() => {
  if (isRecording) {
    frames.push(canvas.toDataURL("image/png"));
  }
});
</script>
<script>
engine.runRenderLoop(() => {
  // Movement via WASD and follow logic already handled elsewhere
  scene.render();
});

window.addEventListener("resize", () => {
  engine.resize();
});
</script>
<script>
window.addEventListener("DOMContentLoaded", () => {
  setTimeout(() => {
    const splash = document.getElementById("splash-screen");
    if (splash) {
      splash.style.transition = "opacity 1s ease";
      splash.style.opacity = 0;
      setTimeout(() => splash.remove(), 1000);
    }
  }, 1000);
});
</script>
<script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("sw.js")
    .then(() => console.log("✅ Service Worker registered"))
    .catch(err => console.warn("Service Worker error:", err));
}
</script>
</body>
</html>
