<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar System Observatory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="favicon.ico" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      background: black;
      font-family: 'Segoe UI', sans-serif;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #splash-screen {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background-color: black;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #splash-screen img {
      max-width: 80%;
      opacity: 0.85;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <div id="splash-screen">
    <img src="splash-loading-screen.png" alt="Loading..." />
  </div>
  <canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color3.Black();

const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.2, 2500, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 20;
camera.upperRadiusLimit = 10000;

const light = new BABYLON.PointLight("SunLight", BABYLON.Vector3.Zero(), scene);
light.intensity = 2.5;

new BABYLON.GlowLayer("glow", scene);
new BABYLON.Layer("starfield", "8k_stars_milky_way.jpg", scene, true);

let timeFactor = 1;
let followPlanet = null;
</script>
<script>
const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

const panel = new BABYLON.GUI.Rectangle();
panel.width = "250px";
panel.background = "rgba(20,20,20,0.85)";
panel.cornerRadius = 8;
panel.thickness = 0;
panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
gui.addControl(panel);

const stack = new BABYLON.GUI.StackPanel();
panel.addControl(stack);

function addButton(label, callback) {
  const btn = BABYLON.GUI.Button.CreateSimpleButton("btn_" + label, label);
  btn.height = "30px";
  btn.width = "100%";
  btn.color = "lightgreen";
  btn.background = "transparent";
  btn.onPointerClickObservable.add(callback);
  stack.addControl(btn);
}
</script>
<script>
const planetsData = [
  { name: "Mercury", distance: 80, speed: 4.8, size: 4, color: new BABYLON.Color3(0.5, 0.5, 0.5) },
  { name: "Venus", distance: 120, speed: 3.5, size: 5.5, color: new BABYLON.Color3(0.9, 0.7, 0.3) },
  { name: "Earth", distance: 160, speed: 2.98, size: 6, color: new BABYLON.Color3(0.4, 0.6, 1) },
  { name: "Mars", distance: 210, speed: 2.4, size: 5, color: new BABYLON.Color3(1, 0.4, 0.3) },
  { name: "Jupiter", distance: 280, speed: 1.3, size: 12, color: new BABYLON.Color3(0.8, 0.6, 0.4) },
  { name: "Saturn", distance: 360, speed: 0.96, size: 10, color: new BABYLON.Color3(1, 0.9, 0.6) },
  { name: "Uranus", distance: 430, speed: 0.68, size: 8, color: new BABYLON.Color3(0.6, 0.9, 1) },
  { name: "Neptune", distance: 490, speed: 0.54, size: 8, color: new BABYLON.Color3(0.3, 0.4, 1) },
  { name: "Pluto", distance: 560, speed: 0.47, size: 2.5, color: new BABYLON.Color3(0.8, 0.8, 0.8) }
];

planetsData.forEach(p => {
  const planet = BABYLON.MeshBuilder.CreateSphere(p.name, { diameter: p.size }, scene);
  const mat = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
  mat.diffuseColor = p.color;
  planet.material = mat;

  scene.registerBeforeRender(() => {
    const t = performance.now() * 0.00001 * p.speed * timeFactor;
    planet.position.x = Math.cos(t) * p.distance;
    planet.position.z = Math.sin(t) * p.distance;
  });

  if (p.name === "Saturn") {
    const ring = BABYLON.MeshBuilder.CreateDisc("SaturnRing", {
      radius: p.size * 2.5,
      tessellation: 64,
      arc: 1
    }, scene);
    const ringMat = new BABYLON.StandardMaterial("SaturnRingMat", scene);
    ringMat.diffuseColor = new BABYLON.Color3(0.8, 0.7, 0.5);
    ringMat.alpha = 0.4;
    ring.material = ringMat;
    ring.rotation.x = Math.PI / 3;
    ring.parent = planet;
  }
});
</script>
<script>
planetsData.forEach(p => {
  const orbit = BABYLON.MeshBuilder.CreateTorus(`${p.name}_orbit`, {
    diameter: p.distance * 2,
    thickness: 0.15,
    tessellation: 100
  }, scene);
  const orbitMat = new BABYLON.StandardMaterial(`${p.name}_orbit_mat`, scene);
  orbitMat.emissiveColor = new BABYLON.Color3(0.2, 0.6, 0.8);
  orbit.material = orbitMat;
  orbit.rotation.x = Math.PI / 2;
});
</script>
<script>
for (let i = 0; i < 300; i++) {
  const angle = Math.random() * Math.PI * 2;
  const radius = 260 + Math.random() * 60;
  const height = (Math.random() - 0.5) * 8;
  const rock = BABYLON.MeshBuilder.CreateSphere(`asteroid_${i}`, { diameter: 0.8 }, scene);
  const mat = new BABYLON.StandardMaterial(`asteroidMat_${i}`, scene);
  mat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.3);
  rock.material = mat;
  rock.position.set(
    Math.cos(angle) * radius,
    height,
    Math.sin(angle) * radius
  );
}
</script>
<script>
const comet = BABYLON.MeshBuilder.CreateSphere("Comet", { diameter: 2 }, scene);
const cometMat = new BABYLON.StandardMaterial("cometMat", scene);
cometMat.emissiveColor = new BABYLON.Color3(0.9, 0.9, 1);
comet.material = cometMat;

const cometTrail = new BABYLON.TrailMesh("cometTrail", comet, scene, 60, 1.2, true);
const trailMat = new BABYLON.StandardMaterial("cometTrailMat", scene);
trailMat.emissiveColor = new BABYLON.Color3(0.5, 0.8, 1);
cometTrail.material = trailMat;

scene.registerBeforeRender(() => {
  const t = performance.now() * 0.00002 * timeFactor;
  comet.position.x = Math.sin(t) * 700;
  comet.position.z = Math.cos(t * 0.8) * 500;
  comet.position.y = Math.sin(t * 0.5) * 80;
});
</script>
<script>
const stellarSystems = [
  {
    name: "Proxima Centauri",
    pos: new BABYLON.Vector3(-5000, 0, 9000),
    color: new BABYLON.Color3(1, 0.5, 0.5),
    planets: [{ name: "Proxima b", dist: 40, size: 3, speed: 0.5 }]
  },
  {
    name: "Alpha Centauri",
    pos: new BABYLON.Vector3(8000, 0, -6000),
    color: new BABYLON.Color3(1, 1, 0.7),
    planets: []
  },
  {
    name: "Kepler-186",
    pos: new BABYLON.Vector3(12000, 0, 12000),
    color: new BABYLON.Color3(0.7, 0.9, 1),
    planets: [{ name: "Kepler-186f", dist: 30, size: 2.8, speed: 0.6 }]
  }
];

stellarSystems.forEach(sys => {
  const star = BABYLON.MeshBuilder.CreateSphere(`${sys.name}_star`, { diameter: 20 }, scene);
  const mat = new BABYLON.StandardMaterial(`${sys.name}_mat`, scene);
  mat.emissiveColor = sys.color;
  star.material = mat;
  star.position = sys.pos;

  sys.planets.forEach((p, i) => {
    const planet = BABYLON.MeshBuilder.CreateSphere(`${sys.name}_${p.name}`, { diameter: p.size }, scene);
    const pm = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
    pm.diffuseColor = BABYLON.Color3.Random();
    planet.material = pm;

    scene.registerBeforeRender(() => {
      const angle = performance.now() * 0.00001 * p.speed * timeFactor + i;
      planet.position.x = sys.pos.x + Math.cos(angle) * p.dist;
      planet.position.z = sys.pos.z + Math.sin(angle) * p.dist;
    });
  });
});
</script>
<script>
function jumpToSystem(name) {
  const sys = stellarSystems.find(s => s.name === name);
  if (!sys) return;

  followPlanet = null;

  const animTarget = new BABYLON.Animation("camToStar", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
  animTarget.setKeys([
    { frame: 0, value: camera.target.clone() },
    { frame: 120, value: sys.pos.clone() }
  ]);

  const animZoom = new BABYLON.Animation("camZoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
  animZoom.setKeys([
    { frame: 0, value: camera.radius },
    { frame: 120, value: 400 }
  ]);

  camera.animations = [animTarget, animZoom];
  scene.beginAnimation(camera, 0, 120, false);

  if (window.speechSynthesis) {
    const msg = new SpeechSynthesisUtterance(`Jumping to ${sys.name}.`);
    msg.lang = "en-US";
    speechSynthesis.speak(msg);
  }
}

addButton("🌌 Stellar Neighborhood", () => {
  const popup = new BABYLON.GUI.StackPanel();
  popup.width = "200px";
  popup.background = "rgba(0,0,0,0.8)";
  popup.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
  popup.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
  gui.addControl(popup);

  stellarSystems.forEach(sys => {
    const btn = BABYLON.GUI.Button.CreateSimpleButton(`sysbtn_${sys.name}`, `↗ ${sys.name}`);
    btn.height = "30px";
    btn.color = "violet";
    btn.background = "transparent";
    btn.onPointerClickObservable.add(() => {
      jumpToSystem(sys.name);
      gui.removeControl(popup);
    });
    popup.addControl(btn);
  });
});
</script>
<script>
const copilotFacts = [
  "Neptune's winds exceed 1,200 mph.",
  "Jupiter’s Great Red Spot is over 300 years old.",
  "Light from Proxima Centauri takes over 4 years to reach Earth.",
  "Saturn's rings are made mostly of ice.",
  "Some asteroids have their own moons."
];

function showCopilotFact() {
  const msg = copilotFacts[Math.floor(Math.random() * copilotFacts.length)];

  const bubble = new BABYLON.GUI.Rectangle("copilotBubble");
  bubble.width = "280px";
  bubble.height = "90px";
  bubble.cornerRadius = 10;
  bubble.color = "white";
  bubble.thickness = 1;
  bubble.background = "rgba(10,10,10,0.85)";
  bubble.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
  bubble.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
  bubble.top = "20px";
  bubble.right = "20px";

  const text = new BABYLON.GUI.TextBlock();
  text.text = msg;
  text.color = "#A0E0FF";
  text.fontSize = 14;
  text.textWrapping = true;
  bubble.addControl(text);
  gui.addControl(bubble);

  if (window.speechSynthesis) {
    const utter = new SpeechSynthesisUtterance(msg);
    utter.lang = "en-US";
    speechSynthesis.speak(utter);
  }

  setTimeout(() => gui.removeControl(bubble), 8000);
}

setInterval(showCopilotFact, 180000); // Every 3 minutes
</script>
<script>
function generateMoons(parentName, count) {
  const parent = scene.getMeshByName(parentName);
  if (!parent) return;

  for (let i = 0; i < count; i++) {
    const moon = BABYLON.MeshBuilder.CreateSphere(`${parentName}_moon_${i}`, { diameter: 1.2 }, scene);
    const mat = new BABYLON.StandardMaterial(`moonMat_${i}`, scene);
    mat.emissiveColor = new BABYLON.Color3(0.6, 0.6, 0.7);
    moon.material = mat;

    const radius = 10 + i * 4;
    const speed = 0.3 + Math.random() * 0.5;
    const offset = Math.random() * Math.PI * 2;

    scene.registerBeforeRender(() => {
      const angle = performance.now() * 0.00002 * speed * timeFactor + offset;
      moon.position.x = parent.position.x + Math.cos(angle) * radius;
      moon.position.z = parent.position.z + Math.sin(angle) * radius;
    });
  }
}

["Jupiter", "Saturn", "Uranus", "Neptune"].forEach(p => generateMoons(p, 3));
</script>
<script>
// 🔍 Zoom In/Out Buttons and [X]/[Z] Keys
addButton("🔍 Zoom In [X]", () => camera.radius *= 0.7);
addButton("🔎 Zoom Out [Z]", () => camera.radius *= 1.5);
window.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  if (key === "x") camera.radius *= 0.7;
  if (key === "z") camera.radius *= 1.5;
});

// ⏱ Time Controls
addButton("⏯ Pause", () => timeFactor = 0);
addButton("⏩ Time x2", () => timeFactor = 2);
addButton("⏩ Time x10", () => timeFactor = 10);
addButton("⏩ Time x100", () => timeFactor = 100);

// 🧠 Target Label
const targetLabel = new BABYLON.GUI.TextBlock();
targetLabel.text = "";
targetLabel.color = "aqua";
targetLabel.fontSize = 16;
targetLabel.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
targetLabel.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
targetLabel.top = "-30px";
gui.addControl(targetLabel);

scene.registerBeforeRender(() => {
  targetLabel.text = followPlanet?.name ? `🎯 Target: ${followPlanet.name}` : "";
});

// ⏳ Time Dilation (Relativity flavor!)
const speedHUD = new BABYLON.GUI.TextBlock();
speedHUD.text = "";
speedHUD.color = "lightgreen";
speedHUD.fontSize = 16;
speedHUD.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
speedHUD.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
speedHUD.top = "50px";
gui.addControl(speedHUD);

scene.registerBeforeRender(() => {
  const speed = Math.abs(timeFactor);
  if (speed >= 1000) {
    const dilation = 1 / Math.sqrt(1 - Math.pow(speed / 299792, 2));
    speedHUD.text = `⏳ Time Dilation: 1s here ≈ ${dilation.toFixed(2)}s on Earth`;
  } else {
    speedHUD.text = "";
  }
});
</script>
<script>
// ❔ Help Overlay [?]
const helpOverlay = new BABYLON.GUI.Rectangle();
helpOverlay.width = "500px";
helpOverlay.height = "200px";
helpOverlay.cornerRadius = 10;
helpOverlay.color = "white";
helpOverlay.background = "rgba(0,0,0,0.9)";
helpOverlay.thickness = 2;
helpOverlay.isVisible = false;
helpOverlay.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
helpOverlay.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
gui.addControl(helpOverlay);

const helpText = new BABYLON.GUI.TextBlock();
helpText.text = `🕹 Controls:
W/A/S/D – Move
Mouse – Orbit
Z – Zoom Out
X – Zoom In
? – Toggle Help
Shift+D – Toggle Debug`;
helpText.color = "#A0E0FF";
helpText.fontSize = 16;
helpText.textWrapping = true;
helpOverlay.addControl(helpText);

window.addEventListener("keydown", e => {
  if (e.key === "?") helpOverlay.isVisible = !helpOverlay.isVisible;
  if (e.shiftKey && e.key.toLowerCase() === "d") {
    scene.debugLayer.isVisible() ? scene.debugLayer.hide() : scene.debugLayer.show();
  }
});
</script>
<script>
// 💾 Save camera position on unload
window.addEventListener("beforeunload", () => {
  localStorage.setItem("cameraTarget", JSON.stringify(camera.target));
  localStorage.setItem("cameraRadius", camera.radius);
});

// 🔁 Restore camera position + fade splash
window.addEventListener("DOMContentLoaded", () => {
  const t = localStorage.getItem("cameraTarget");
  const r = localStorage.getItem("cameraRadius");
  if (t) camera.setTarget(BABYLON.Vector3.FromArray(JSON.parse(t)));
  if (r) camera.radius = parseFloat(r);

  setTimeout(() => {
    const splash = document.getElementById("splash-screen");
    if (splash) {
      splash.style.transition = "opacity 1s ease";
      splash.style.opacity = 0;
      setTimeout(() => splash.remove(), 1000);
    }
  }, 1000);
});

// 🎥 Render Loop + Resize
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());
</script>
<script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("sw.js")
    .then(() => console.log("✅ Service Worker registered"))
    .catch(err => console.warn("Service Worker error:", err));
}
</script>
</body>
</html>
