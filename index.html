<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Galactic Observatory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="favicon.ico" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      background: black; font-family: sans-serif;
      overflow: hidden;
    }
    canvas { display: block; width: 100%; height: 100%; }
    #splash-screen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    #splash-screen img {
      max-width: 80%;
      max-height: 80%;
      opacity: 0.9;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <div id="splash-screen">
    <img src="splash-loading-screen.png" alt="Loading Galactic Observatory..." />
  </div>
  <canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = BABYLON.Color3.Black();

const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI/2, Math.PI/2.2, 2500, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 20;

const light = new BABYLON.PointLight("sunLight", BABYLON.Vector3.Zero(), scene);
light.intensity = 2.5;

const starfield = new BABYLON.Layer("starfield", "8k_stars_milky_way.jpg", scene, true);

const sun = BABYLON.MeshBuilder.CreateSphere("Sun", { diameter: 18 }, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveColor = new BABYLON.Color3(1, 0.85, 0.2);
sun.material = sunMat;

const glowLayer = new BABYLON.GlowLayer("glow", scene);
let timeFactor = 1;
</script>
<script>
function createPlanet(name, size, dist, speed, color, moons = []) {
  const planet = BABYLON.MeshBuilder.CreateSphere(name, { diameter: size }, scene);
  const mat = new BABYLON.StandardMaterial(`${name}_mat`, scene);
  mat.diffuseColor = color;
  planet.material = mat;

  let angle = Math.random() * Math.PI * 2;
  scene.registerBeforeRender(() => {
    angle += speed * timeFactor;
    planet.position.x = Math.cos(angle) * dist;
    planet.position.z = Math.sin(angle) * dist;
  });

  // Moon System
  moons.forEach((moon, i) => {
    const m = BABYLON.MeshBuilder.CreateSphere(`${name}_moon_${i}`, { diameter: moon.size }, scene);
    const mMat = new BABYLON.StandardMaterial(`${name}_moonMat_${i}`, scene);
    mMat.diffuseColor = moon.color;
    m.material = mMat;
    let mAngle = Math.random() * Math.PI * 2;
    scene.registerBeforeRender(() => {
      mAngle += moon.speed * timeFactor;
      m.position.x = planet.position.x + Math.cos(mAngle) * moon.distance;
      m.position.z = planet.position.z + Math.sin(mAngle) * moon.distance;
    });
  });

  // Label
  const labelPlane = BABYLON.MeshBuilder.CreatePlane(`${name}_label`, { size: 8 }, scene);
  labelPlane.parent = planet;
  labelPlane.position.y = size + 2;
  const guiTex = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(labelPlane);
  const text = new BABYLON.GUI.TextBlock();
  text.text = name;
  text.color = "white";
  text.fontSize = 24;
  guiTex.addControl(text);

  // Planet click interaction
  planet.actionManager = new BABYLON.ActionManager(scene);
  planet.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
    BABYLON.ActionManager.OnPickTrigger,
    () => showPlanetInfo(name)
  ));

  return planet;
}
</script>
<script>
const planets = [
  { name: "Mercury", size: 1.5, dist: 58, speed: 0.0047, color: BABYLON.Color3.Gray(), moons: [] },
  { name: "Venus", size: 2.2, dist: 108, speed: 0.0035, color: new BABYLON.Color3(1.0, 0.85, 0.6), moons: [] },
  { name: "Earth", size: 2.5, dist: 150, speed: 0.003, color: new BABYLON.Color3(0.3, 0.6, 1), moons: [
    { size: 0.7, distance: 5, speed: 0.03, color: BABYLON.Color3.White() }
  ] },
  { name: "Mars", size: 2.0, dist: 228, speed: 0.0024, color: new BABYLON.Color3(0.9, 0.4, 0.3), moons: [
    { size: 0.4, distance: 4, speed: 0.035, color: BABYLON.Color3.Gray() },
    { size: 0.4, distance: 6, speed: 0.028, color: BABYLON.Color3.Gray() }
  ] },
  { name: "Jupiter", size: 6.0, dist: 778, speed: 0.0013, color: new BABYLON.Color3(0.9, 0.8, 0.6), moons: [
    { size: 1.1, distance: 10, speed: 0.018, color: BABYLON.Color3.White() },
    { size: 1.0, distance: 13, speed: 0.015, color: BABYLON.Color3.White() },
    { size: 1.0, distance: 15, speed: 0.012, color: BABYLON.Color3.White() }
  ] },
  { name: "Saturn", size: 5.5, dist: 1430, speed: 0.00095, color: new BABYLON.Color3(1.0, 0.9, 0.5), moons: [
    { size: 0.9, distance: 11, speed: 0.013, color: BABYLON.Color3.Yellow() }
  ] },
  { name: "Uranus", size: 4.5, dist: 2870, speed: 0.00068, color: new BABYLON.Color3(0.6, 0.9, 1), moons: [] },
  { name: "Neptune", size: 4.3, dist: 4495, speed: 0.00054, color: new BABYLON.Color3(0.3, 0.5, 1), moons: [] },
  { name: "Pluto", size: 1.1, dist: 5900, speed: 0.00047, color: new BABYLON.Color3(0.8, 0.8, 1), moons: [] },
  { name: "Ceres", size: 0.9, dist: 413, speed: 0.0015, color: new BABYLON.Color3(0.9, 0.9, 0.9), moons: [] },
  { name: "Eris", size: 1.0, dist: 6700, speed: 0.00041, color: new BABYLON.Color3(1.0, 1.0, 0.9), moons: [] }
];
</script>
<script>
const orbitLines = [];

planets.forEach(p => {
  createPlanet(p.name, p.size, p.dist, p.speed, p.color, p.moons);

  const points = [];
  for (let i = 0; i <= 360; i++) {
    const rad = BABYLON.Tools.ToRadians(i);
    points.push(new BABYLON.Vector3(
      Math.cos(rad) * p.dist,
      0,
      Math.sin(rad) * p.dist
    ));
  }

  const orbit = BABYLON.MeshBuilder.CreateLines(`${p.name}_orbit`, { points }, scene);
  orbit.color = BABYLON.Color3.White();
  orbit.alpha = 0.04;
  orbitLines.push(orbit);
});
</script>
<script>
for (let i = 0; i < 400; i++) {
  const dist = 400 + Math.random() * 200;
  const size = 0.2 + Math.random() * 0.3;
  const theta = Math.random() * Math.PI * 2;

  const a = BABYLON.MeshBuilder.CreateSphere("asteroid" + i, { diameter: size }, scene);
  const mat = new BABYLON.StandardMaterial("asteroidMat" + i, scene);
  mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5);
  a.material = mat;

  scene.registerBeforeRender(() => {
    const t = theta + engine.getDeltaTime() * 0.0000018 * i;
    a.position.x = Math.cos(t) * dist;
    a.position.z = Math.sin(t) * dist;
    a.position.y = Math.sin(i * 0.008) * 1.5;
  });
}
</script>
<script>
// Satellite around Earth
const satellite = BABYLON.MeshBuilder.CreateBox("satellite", { size: 0.5 }, scene);
const satMat = new BABYLON.StandardMaterial("satMat", scene);
satMat.diffuseColor = new BABYLON.Color3(0.8, 0.8, 0.2);
satellite.material = satMat;

let satAngle = 0;
scene.registerBeforeRender(() => {
  satAngle += 0.01 * timeFactor;
  const earth = scene.getMeshByName("Earth");
  if (earth) {
    satellite.position.x = earth.position.x + Math.cos(satAngle) * 10;
    satellite.position.z = earth.position.z + Math.sin(satAngle) * 10;
    satellite.position.y = 2;
  }
});
</script>
<script>
const comet = BABYLON.MeshBuilder.CreateSphere("comet", { diameter: 1 }, scene);
const cometMat = new BABYLON.StandardMaterial("cometMat", scene);
cometMat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 1);
comet.material = cometMat;

let cometT = 0;
scene.registerBeforeRender(() => {
  cometT += 0.002 * timeFactor;
  const a = 1800, b = 400;
  const angle = cometT * Math.PI * 2;
  comet.position.x = Math.cos(angle) * a;
  comet.position.z = Math.sin(angle) * b;
  comet.position.y = Math.sin(cometT * 3) * 60;
});

// Particle trail
const cometTrail = new BABYLON.ParticleSystem("trail", 500, scene);
cometTrail.particleTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
cometTrail.emitter = comet;
cometTrail.minEmitBox = new BABYLON.Vector3(-0.1, 0, -0.1);
cometTrail.maxEmitBox = new BABYLON.Vector3(0.1, 0, 0.1);
cometTrail.color1 = new BABYLON.Color4(1, 1, 1, 1);
cometTrail.color2 = new BABYLON.Color4(0.5, 0.5, 1, 0.5);
cometTrail.minSize = 0.3;
cometTrail.maxSize = 0.7;
cometTrail.minLifeTime = 0.5;
cometTrail.maxLifeTime = 1;
cometTrail.emitRate = 200;
cometTrail.direction1 = new BABYLON.Vector3(-1, 0, -1);
cometTrail.direction2 = new BABYLON.Vector3(1, 0, 1);
cometTrail.gravity = new BABYLON.Vector3(0, 0, 0);
cometTrail.start();
</script>
<script>
function addAtmosphereTo(planetName, color) {
  const basePlanet = scene.getMeshByName(planetName);
  if (!basePlanet) return;
  const glow = BABYLON.MeshBuilder.CreateSphere(`${planetName}_atmosphere`, {
    diameter: basePlanet.scaling.x * 1.2 || basePlanet.getBoundingInfo().boundingBox.extendSizeWorld.x * 2.4
  }, scene);
  glow.material = new BABYLON.StandardMaterial(`${planetName}_atmoMat`, scene);
  glow.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
  glow.material.emissiveColor = color;
  glow.material.alpha = 0.2;
  glow.parent = basePlanet;
}

addAtmosphereTo("Earth", new BABYLON.Color3(0.4, 0.8, 1));
addAtmosphereTo("Venus", new BABYLON.Color3(1.0, 0.9, 0.6));
</script>
<script>
const constellations = {
  Orion: [
    new BABYLON.Vector3(-80, 40, 60),
    new BABYLON.Vector3(-70, 42, 55),
    new BABYLON.Vector3(-60, 41, 50)
  ],
  UrsaMajor: [
    new BABYLON.Vector3(200, 90, -400),
    new BABYLON.Vector3(220, 92, -390),
    new BABYLON.Vector3(240, 94, -380),
    new BABYLON.Vector3(260, 93, -370),
    new BABYLON.Vector3(280, 91, -360),
    new BABYLON.Vector3(300, 89, -350),
    new BABYLON.Vector3(320, 87, -340)
  ]
};

const constellationLines = [];

Object.entries(constellations).forEach(([name, stars]) => {
  stars.forEach((pos, i) => {
    const star = BABYLON.MeshBuilder.CreateSphere(`${name}_star_${i}`, { diameter: 2 }, scene);
    star.position = pos;
    const mat = new BABYLON.StandardMaterial(`${name}_mat_${i}`, scene);
    mat.emissiveColor = BABYLON.Color3.White();
    star.material = mat;

    if (i < stars.length - 1) {
      const line = BABYLON.MeshBuilder.CreateLines(`${name}_line_${i}`, {
        points: [stars[i], stars[i + 1]]
      }, scene);
      line.color = new BABYLON.Color3(0.5, 0.8, 1);
      line.alpha = 0.6;
      constellationLines.push(line);
    }
  });
});
</script>
<script>
const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

// Control panel container
const panel = new BABYLON.GUI.Rectangle();
panel.width = "250px";
panel.background = "rgba(20,20,20,0.85)";
panel.cornerRadius = 8;
panel.thickness = 0;
panel.paddingTop = "10px";
panel.paddingLeft = "10px";
panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
panel.isVisible = true;
gui.addControl(panel);

const stack = new BABYLON.GUI.StackPanel();
panel.addControl(stack);

// Helper to add buttons
function addButton(label, callback) {
  const btn = BABYLON.GUI.Button.CreateSimpleButton(label, label);
  btn.height = "30px";
  btn.width = "100%";
  btn.color = "lightgreen";
  btn.background = "transparent";
  btn.onPointerClickObservable.add(callback);
  stack.addControl(btn);
}

// Time and visibility toggles
addButton("Pause", () => timeFactor = 0);
addButton("1x Speed", () => timeFactor = 1);
addButton("10x Speed", () => timeFactor = 10);
addButton("Toggle Orbits", () => orbitLines.forEach(l => l.setEnabled(!l.isEnabled())));
addButton("Toggle Constellations", () => constellationLines.forEach(l => l.setEnabled(!l.isEnabled())));
addButton("Toggle Asteroids", () =>
  scene.meshes.filter(m => m.name.startsWith("asteroid")).forEach(m => m.setEnabled(!m.isEnabled()))
);

// Fly-to menu
["Mercury","Venus","Earth","Mars","Jupiter","Saturn","Uranus","Neptune","Pluto","Ceres","Eris"].forEach(name => {
  addButton(`Go to ${name}`, () => {
    const target = scene.getMeshByName(name);
    if (target) {
      camera.setTarget(target.position);
      camera.radius = 200;
    }
  });
});

// Time speed slider
const slider = new BABYLON.GUI.Slider();
slider.minimum = -10;
slider.maximum = 10;
slider.value = timeFactor;
slider.height = "20px";
slider.color = "lightblue";
slider.background = "gray";
slider.onValueChangedObservable.add(v => timeFactor = v);
stack.addControl(new BABYLON.GUI.TextBlock("speedLabel", "Time Speed (slider):"));
stack.addControl(slider);

// Screenshot button
addButton("📷 Take Screenshot", () => {
  BABYLON.Tools.CreateScreenshotUsingRenderTarget(engine, camera, { width: 1920, height: 1080 });
});

// Telescope mode
addButton("🔭 Telescope Mode (T)", () => {
  camera.radius = 60;
});

// Quiz toggle
addButton("🎓 Toggle Quiz Mode", () => {
  alert("👨‍🚀 Coming soon: interactive quizzes with multiple choice and planet tours!");
});
</script>
<script>
// Camera movement keys
const moveKeys = { forward: false, back: false, left: false, right: false };

scene.onKeyboardObservable.add(kb => {
  const pressed = kb.type === BABYLON.KeyboardEventTypes.KEYDOWN;
  const key = kb.event.key.toLowerCase();
  if (key === "w" || key === "arrowup") moveKeys.forward = pressed;
  else if (key === "s" || key === "arrowdown") moveKeys.back = pressed;
  else if (key === "a" || key === "arrowleft") moveKeys.left = pressed;
  else if (key === "d" || key === "arrowright") moveKeys.right = pressed;
});

window.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  if (key === "t") camera.radius = 60; // Telescope
  else if (key === "x") camera.radius *= 0.8;
  else if (key === "z") {
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.radius = 2500;
  } else if (key === "f") {
    document.fullscreenElement
      ? document.exitFullscreen()
      : document.documentElement.requestFullscreen();
  }
});

// Animate movement
engine.runRenderLoop(() => {
  const speed = 5;
  const dir = new BABYLON.Vector3(
    (moveKeys.right ? 1 : 0) - (moveKeys.left ? 1 : 0),
    0,
    (moveKeys.back ? 1 : 0) - (moveKeys.forward ? 1 : 0)
  );

  if (!dir.equals(BABYLON.Vector3.Zero())) {
    const rot = BABYLON.Vector3.TransformCoordinates(dir, BABYLON.Matrix.RotationY(camera.alpha));
    camera.target.addInPlace(rot.scale(speed));
  }

  scene.render();
});

window.addEventListener("resize", () => engine.resize());
</script>
<script>
// Splash fade-out
window.addEventListener("DOMContentLoaded", () => {
  setTimeout(() => {
    const splash = document.getElementById("splash-screen");
    if (splash) {
      splash.style.transition = "opacity 1s ease";
      splash.style.opacity = 0;
      setTimeout(() => splash.remove(), 1000);
    }
  }, 1000);
});

// PWA service worker
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("sw.js")
    .then(() => console.log("✅ Service Worker registered"))
    .catch(err => console.error("🛑 Service Worker registration failed:", err));
}
</script>
</body>
</html>
