<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar Observatory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="favicon.ico" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: black;
      font-family: 'Segoe UI', sans-serif;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #splash-screen {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background-color: black;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #splash-screen img {
      max-width: 80%;
      opacity: 0.8;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <div id="splash-screen">
    <img src="splash-loading-screen.png" alt="Loading..." />
  </div>
  <canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color3.Black();

const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.2, 2500, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 20;
camera.upperRadiusLimit = 10000;

const light = new BABYLON.PointLight("SunLight", BABYLON.Vector3.Zero(), scene);
light.intensity = 2.5;

const glowLayer = new BABYLON.GlowLayer("glow", scene);
const starfield = new BABYLON.Layer("starfield", "8k_stars_milky_way.jpg", scene, true);

// Global time multiplier and follow lock
let timeFactor = 1;
let followPlanet = null;
</script>
<script>
const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

const panel = new BABYLON.GUI.Rectangle();
panel.width = "250px";
panel.background = "rgba(20,20,20,0.85)";
panel.cornerRadius = 8;
panel.thickness = 0;
panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
gui.addControl(panel);

const stack = new BABYLON.GUI.StackPanel();
panel.addControl(stack);

function addButton(label, callback) {
  const btn = BABYLON.GUI.Button.CreateSimpleButton("btn_" + label, label);
  btn.height = "30px";
  btn.width = "100%";
  btn.color = "lightgreen";
  btn.background = "transparent";
  btn.onPointerClickObservable.add(callback);
  stack.addControl(btn);
}
</script>
<script>
// Central star
const sun = BABYLON.MeshBuilder.CreateSphere("Sun", { diameter: 30 }, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveColor = new BABYLON.Color3(1, 0.8, 0.1);
sunMat.disableLighting = true;
sun.material = sunMat;
sun.position = BABYLON.Vector3.Zero();
</script>
<script>
const planetsData = [
  { name: "Mercury", distance: 80, speed: 4.8, size: 4, color: new BABYLON.Color3(0.5, 0.5, 0.5) },
  { name: "Venus", distance: 120, speed: 3.5, size: 5.5, color: new BABYLON.Color3(0.9, 0.7, 0.3) },
  { name: "Earth", distance: 160, speed: 2.98, size: 6, color: new BABYLON.Color3(0.4, 0.6, 1) },
  { name: "Mars", distance: 210, speed: 2.4, size: 5, color: new BABYLON.Color3(1, 0.4, 0.3) },
  { name: "Jupiter", distance: 280, speed: 1.3, size: 12, color: new BABYLON.Color3(0.8, 0.6, 0.4) },
  { name: "Saturn", distance: 360, speed: 0.96, size: 10, color: new BABYLON.Color3(1, 0.9, 0.6) },
  { name: "Uranus", distance: 430, speed: 0.68, size: 8, color: new BABYLON.Color3(0.6, 0.9, 1) },
  { name: "Neptune", distance: 490, speed: 0.54, size: 8, color: new BABYLON.Color3(0.3, 0.4, 1) },
  { name: "Pluto", distance: 560, speed: 0.47, size: 2.5, color: new BABYLON.Color3(0.8, 0.8, 0.8) }
];

planetsData.forEach(p => {
  const planet = BABYLON.MeshBuilder.CreateSphere(p.name, { diameter: p.size }, scene);
  const mat = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
  mat.diffuseColor = p.color;
  planet.material = mat;

  scene.registerBeforeRender(() => {
    const t = performance.now() * 0.00001 * p.speed * timeFactor;
    planet.position.x = Math.cos(t) * p.distance;
    planet.position.z = Math.sin(t) * p.distance;
    planet.position.y = 0;
  });

  if (p.name === "Saturn") {
    const ring = BABYLON.MeshBuilder.CreateDisc("SaturnRing", {
      radius: p.size * 2,
      tessellation: 64,
      arc: 1
    }, scene);
    const ringMat = new BABYLON.StandardMaterial("SaturnRingMat", scene);
    ringMat.diffuseColor = new BABYLON.Color3(0.8, 0.7, 0.5);
    ringMat.alpha = 0.4;
    ring.material = ringMat;
    ring.rotation.x = Math.PI / 3;
    ring.parent = planet;
  }
});
</script>
<script>
planetsData.forEach(p => {
  const orbit = BABYLON.MeshBuilder.CreateTorus(`${p.name}_orbit`, {
    diameter: p.distance * 2,
    thickness: 0.15,
    tessellation: 100
  }, scene);

  const orbitMat = new BABYLON.StandardMaterial(`${p.name}_orbit_mat`, scene);
  orbitMat.emissiveColor = new BABYLON.Color3(0.2, 0.6, 0.8);
  orbit.material = orbitMat;
  orbit.rotation.x = Math.PI / 2;
});
</script>
<script>
const asteroidCount = 300;
for (let i = 0; i < asteroidCount; i++) {
  const angle = Math.random() * Math.PI * 2;
  const radius = 260 + Math.random() * 60;
  const height = (Math.random() - 0.5) * 8;

  const rock = BABYLON.MeshBuilder.CreateSphere(`asteroid_${i}`, { diameter: 0.8 }, scene);
  const mat = new BABYLON.StandardMaterial(`asteroidMat_${i}`, scene);
  mat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.3);
  rock.material = mat;
  rock.position.set(
    Math.cos(angle) * radius,
    height,
    Math.sin(angle) * radius
  );
}
</script>
<script>
const comet = BABYLON.MeshBuilder.CreateSphere("Comet", { diameter: 2 }, scene);
const cometMat = new BABYLON.StandardMaterial("cometMat", scene);
cometMat.emissiveColor = new BABYLON.Color3(0.9, 0.9, 1);
comet.material = cometMat;

const cometTrail = new BABYLON.TrailMesh("cometTrail", comet, scene, 60, 1.2, true);
const trailMat = new BABYLON.StandardMaterial("cometTrailMat", scene);
trailMat.emissiveColor = new BABYLON.Color3(0.5, 0.8, 1);
cometTrail.material = trailMat;

scene.registerBeforeRender(() => {
  const t = performance.now() * 0.00002 * timeFactor;
  comet.position.x = Math.sin(t) * 700;
  comet.position.z = Math.cos(t * 0.8) * 500;
  comet.position.y = Math.sin(t * 0.5) * 80;
});
</script>
<script>
const stellarSystems = [
  {
    name: "Proxima Centauri",
    pos: new BABYLON.Vector3(-5000, 0, 9000),
    color: new BABYLON.Color3(1, 0.5, 0.5),
    planets: [
      { name: "Proxima b", dist: 40, size: 3, speed: 0.5 }
    ]
  },
  {
    name: "Alpha Centauri",
    pos: new BABYLON.Vector3(8000, 0, -6000),
    color: new BABYLON.Color3(1, 1, 0.7),
    planets: []
  },
  {
    name: "Kepler-186",
    pos: new BABYLON.Vector3(12000, 0, 12000),
    color: new BABYLON.Color3(0.7, 0.9, 1),
    planets: [
      { name: "Kepler-186f", dist: 30, size: 2.8, speed: 0.6 }
    ]
  }
];

// Create stellar systems
stellarSystems.forEach(sys => {
  const star = BABYLON.MeshBuilder.CreateSphere(`${sys.name}_star`, { diameter: 20 }, scene);
  const mat = new BABYLON.StandardMaterial(`${sys.name}_mat`, scene);
  mat.emissiveColor = sys.color;
  star.material = mat;
  star.position = sys.pos;

  sys.planets.forEach((p, i) => {
    const planet = BABYLON.MeshBuilder.CreateSphere(`${sys.name}_${p.name}`, { diameter: p.size }, scene);
    const pm = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
    pm.diffuseColor = BABYLON.Color3.Random();
    planet.material = pm;

    scene.registerBeforeRender(() => {
      const angle = performance.now() * 0.00001 * p.speed * timeFactor + i;
      planet.position.x = sys.pos.x + Math.cos(angle) * p.dist;
      planet.position.z = sys.pos.z + Math.sin(angle) * p.dist;
      planet.position.y = sys.pos.y;
    });
  });
});
</script>
<script>
function jumpToSystem(name) {
  const sys = stellarSystems.find(s => s.name === name);
  if (!sys) return;

  followPlanet = null;

  const animTarget = new BABYLON.Animation("camToStar", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
  animTarget.setKeys([
    { frame: 0, value: camera.target.clone() },
    { frame: 120, value: sys.pos.clone() }
  ]);

  const animZoom = new BABYLON.Animation("camZoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
  animZoom.setKeys([
    { frame: 0, value: camera.radius },
    { frame: 120, value: 400 }
  ]);

  camera.animations = [animTarget, animZoom];
  scene.beginAnimation(camera, 0, 120, false);

  if (window.speechSynthesis) {
    const msg = new SpeechSynthesisUtterance(`Jumping to ${sys.name}.`);
    msg.lang = "en-US";
    speechSynthesis.speak(msg);
  }
}

// Add jump menu
addButton("🌌 Stellar Neighborhood", () => {
  const popup = new BABYLON.GUI.StackPanel();
  popup.width = "200px";
  popup.height = "auto";
  popup.background = "rgba(0,0,0,0.8)";
  popup.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
  popup.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
  gui.addControl(popup);

  stellarSystems.forEach(sys => {
    const btn = BABYLON.GUI.Button.CreateSimpleButton(`sysbtn_${sys.name}`, `↗ ${sys.name}`);
    btn.height = "30px";
    btn.color = "violet";
    btn.background = "transparent";
    btn.onPointerClickObservable.add(() => {
      jumpToSystem(sys.name);
      gui.removeControl(popup);
    });
    popup.addControl(btn);
  });
});
</script>
<script>
function generateMoons(parentName, count) {
  const parent = scene.getMeshByName(parentName);
  if (!parent) return;

  for (let i = 0; i < count; i++) {
    const moon = BABYLON.MeshBuilder.CreateSphere(`${parentName}_moon_${i}`, { diameter: 1.2 }, scene);
    const mat = new BABYLON.StandardMaterial(`moonMat_${i}`, scene);
    mat.emissiveColor = new BABYLON.Color3(0.6, 0.6, 0.7);
    moon.material = mat;

    const radius = 10 + i * 4;
    const speed = 0.3 + Math.random() * 0.5;
    const offset = Math.random() * Math.PI * 2;

    scene.registerBeforeRender(() => {
      const angle = performance.now() * 0.00002 * speed * timeFactor + offset;
      moon.position.x = parent.position.x + Math.cos(angle) * radius;
      moon.position.z = parent.position.z + Math.sin(angle) * radius;
      moon.position.y = parent.position.y;
    });
  }
}

["Jupiter", "Saturn", "Uranus", "Neptune"].forEach(p => generateMoons(p, 3));
</script>
<script>
const copilotFacts = [
  "Neptune has winds faster than sound.",
  "Pluto's orbit is tilted compared to the other planets.",
  "Jupiter protects Earth by deflecting comets.",
  "The Oort Cloud may contain trillions of icy bodies.",
  "Light from the Sun takes 8 minutes to reach Earth."
];

function showCopilotFact() {
  const msg = copilotFacts[Math.floor(Math.random() * copilotFacts.length)];

  const bubble = new BABYLON.GUI.Rectangle("copilotBubble");
  bubble.width = "280px";
  bubble.height = "90px";
  bubble.cornerRadius = 10;
  bubble.color = "white";
  bubble.thickness = 1;
  bubble.background = "rgba(10,10,10,0.85)";
  bubble.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
  bubble.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
  bubble.top = "20px";
  bubble.right = "20px";

  const text = new BABYLON.GUI.TextBlock();
  text.text = msg;
  text.color = "#A0E0FF";
  text.fontSize = 14;
  text.textWrapping = true;
  bubble.addControl(text);
  gui.addControl(bubble);

  if (window.speechSynthesis) {
    const utter = new SpeechSynthesisUtterance(msg);
    utter.lang = "en-US";
    speechSynthesis.speak(utter);
  }

  setTimeout(() => gui.removeControl(bubble), 8000);
}

// Trigger every 3 minutes
setInterval(showCopilotFact, 180000);
</script>
<script>
function triggerMeteorShower() {
  const meteors = [];
  for (let i = 0; i < 40; i++) {
    const m = BABYLON.MeshBuilder.CreateSphere(`meteor_${i}`, { diameter: 0.4 }, scene);
    const mat = new BABYLON.StandardMaterial(`meteorMat_${i}`, scene);
    mat.emissiveColor = new BABYLON.Color3(1, 0.5, 0.2);
    mat.alpha = 0.6;
    m.material = mat;

    const start = new BABYLON.Vector3(
      Math.random() * 800 - 400,
      150 + Math.random() * 100,
      Math.random() * 800 - 400
    );
    m.position = start;

    const direction = new BABYLON.Vector3(-1, -1.2, 0).normalize().scale(3 + Math.random() * 2);
    meteors.push({ mesh: m, dir: direction, age: 0 });
  }

  scene.registerBeforeRender(() => {
    meteors.forEach(m => {
      if (m.mesh) {
        m.mesh.position.addInPlace(m.dir);
        m.age++;
        if (m.age > 100) {
          m.mesh.dispose();
          m.mesh = null;
        }
      }
    });
  });
}

// Automatically trigger meteor shower during Perseids week
const today = new Date();
if (today.getMonth() === 7 && today.getDate() >= 10 && today.getDate() <= 15) {
  triggerMeteorShower();
  if (window.speechSynthesis) {
    speechSynthesis.speak(new SpeechSynthesisUtterance("Perseid meteor shower active this week."));
  }
}
</script>
<script>
function fetchLaunches() {
  fetch("https://ll.thespacedevs.com/2.2.0/launch/upcoming/?limit=3")
    .then(res => res.json())
    .then(data => {
      const launches = data.results.map(l =>
        `${l.name} — ${new Date(l.window_start).toLocaleString()}`
      ).join("\n");

      const launchPanel = new BABYLON.GUI.Rectangle();
      launchPanel.width = "300px";
      launchPanel.height = "130px";
      launchPanel.cornerRadius = 10;
      launchPanel.color = "white";
      launchPanel.thickness = 1;
      launchPanel.background = "rgba(10,10,20,0.85)";
      launchPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
      launchPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
      launchPanel.top = "20px";
      launchPanel.left = "20px";
      gui.addControl(launchPanel);

      const launchBox = new BABYLON.GUI.TextBlock();
      launchBox.text = "🚀 Upcoming Launches:\n" + launches;
      launchBox.color = "white";
      launchBox.fontSize = 14;
      launchBox.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
      launchBox.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
      launchBox.textWrapping = true;
      launchBox.paddingTop = 8;
      launchBox.paddingLeft = 8;
      launchPanel.addControl(launchBox);

      if (window.speechSynthesis) {
        const msg = new SpeechSynthesisUtterance("Upcoming launches displayed at top left.");
        msg.lang = "en-US";
        speechSynthesis.speak(msg);
      }
    }).catch(err => {
      console.warn("Launch API failed:", err);
    });
}

fetchLaunches();
</script>
<script>
const speedHUD = new BABYLON.GUI.TextBlock();
speedHUD.text = "";
speedHUD.color = "lightgreen";
speedHUD.fontSize = 16;
speedHUD.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
speedHUD.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
speedHUD.top = "50px";
gui.addControl(speedHUD);

scene.registerBeforeRender(() => {
  const speed = Math.abs(timeFactor);
  if (speed >= 1000) {
    const dilation = 1 / Math.sqrt(1 - Math.pow(speed / 299792, 2));
    speedHUD.text = `⏳ Time Dilation: 1s here ≈ ${dilation.toFixed(2)}s on Earth`;
  } else {
    speedHUD.text = "";
  }
});
</script>
<script>
// Keep camera locked on focused object
scene.onBeforeRenderObservable.add(() => {
  if (followPlanet && followPlanet.position) {
    camera.setTarget(followPlanet.position.clone());
  }
});

// GUI menu to select and zoom to a planet
const planetPanel = new BABYLON.GUI.StackPanel();
planetPanel.isVisible = false;
gui.addControl(planetPanel);

addButton("🔭 Select Planet", () => {
  planetPanel.clearControls();
  planetsData.forEach(p => {
    const btn = BABYLON.GUI.Button.CreateSimpleButton(`btn_${p.name}`, p.name);
    btn.height = "30px";
    btn.color = "lightblue";
    btn.background = "rgba(30,30,30,0.7)";
    btn.onPointerClickObservable.add(() => {
      const obj = scene.getMeshByName(p.name);
      if (!obj) return;

      followPlanet = obj;

      const animTarget = new BABYLON.Animation("focusTarget", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
      animTarget.setKeys([
        { frame: 0, value: camera.target.clone() },
        { frame: 90, value: obj.position.clone() }
      ]);

      const animZoom = new BABYLON.Animation("focusZoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
      animZoom.setKeys([
        { frame: 0, value: camera.radius },
        { frame: 90, value: 60 }
      ]);

      camera.animations = [animTarget, animZoom];
      scene.beginAnimation(camera, 0, 90, false);
    });
    planetPanel.addControl(btn);
  });

  planetPanel.isVisible = !planetPanel.isVisible;
});

// Keyboard shortcut: Z to zoom out
window.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "z") {
    camera.radius *= 1.5;
    followPlanet = null;
  }
});
</script>
<script>
engine.runRenderLoop(() => {
  scene.render();
});

window.addEventListener("resize", () => {
  engine.resize();
});
</script>
<script>
window.addEventListener("DOMContentLoaded", () => {
  setTimeout(() => {
    const splash = document.getElementById("splash-screen");
    if (splash) {
      splash.style.transition = "opacity 1s ease";
      splash.style.opacity = 0;
      setTimeout(() => splash.remove(), 1000);
    }
  }, 1000);
});
</script>
<script>
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("sw.js")
    .then(() => console.log("✅ Service Worker registered"))
    .catch(err => console.warn("Service Worker error:", err));
}
</script>
</body>
</html>
