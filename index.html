<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar System Observatory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="favicon.ico" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: black;
      font-family: 'Segoe UI', sans-serif;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #splash-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background-color: black;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }
    #splash-screen img {
      max-width: 80%;
      opacity: 0.85;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <div id="splash-screen">
    <img src="splash-loading-screen.png" alt="Loading..." />
  </div>
  <canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color3.Black();

const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.2, 2500, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 20;
camera.upperRadiusLimit = 10000;

const light = new BABYLON.PointLight("SunLight", BABYLON.Vector3.Zero(), scene);
light.intensity = 2.5;

const glowLayer = new BABYLON.GlowLayer("glow", scene);
const starfield = new BABYLON.Layer("starfield", "8k_stars_milky_way.jpg", scene, true);

let timeFactor = 1;
let followPlanet = null;
</script>
<script>
const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

const panel = new BABYLON.GUI.Rectangle();
panel.width = "250px";
panel.background = "rgba(20,20,20,0.85)";
panel.cornerRadius = 8;
panel.thickness = 0;
panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
gui.addControl(panel);

const stack = new BABYLON.GUI.StackPanel();
panel.addControl(stack);

function addButton(label, callback) {
  const btn = BABYLON.GUI.Button.CreateSimpleButton("btn_" + label, label);
  btn.height = "30px";
  btn.width = "100%";
  btn.color = "lightgreen";
  btn.background = "transparent";
  btn.onPointerClickObservable.add(callback);
  stack.addControl(btn);
}
</script>
<script>
const sun = BABYLON.MeshBuilder.CreateSphere("Sun", { diameter: 30 }, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveColor = new BABYLON.Color3(1, 0.8, 0.1);
sunMat.disableLighting = true;
sun.material = sunMat;
sun.position = BABYLON.Vector3.Zero();
</script>
<script>
const planetsData = [
  { name: "Mercury", distance: 80, speed: 4.8, size: 4, color: new BABYLON.Color3(0.5, 0.5, 0.5) },
  { name: "Venus", distance: 120, speed: 3.5, size: 5.5, color: new BABYLON.Color3(0.9, 0.7, 0.3) },
  { name: "Earth", distance: 160, speed: 2.98, size: 6, color: new BABYLON.Color3(0.4, 0.6, 1) },
  { name: "Mars", distance: 210, speed: 2.4, size: 5, color: new BABYLON.Color3(1, 0.4, 0.3) },
  { name: "Jupiter", distance: 280, speed: 1.3, size: 12, color: new BABYLON.Color3(0.8, 0.6, 0.4) },
  { name: "Saturn", distance: 360, speed: 0.96, size: 10, color: new BABYLON.Color3(1, 0.9, 0.6) },
  { name: "Uranus", distance: 430, speed: 0.68, size: 8, color: new BABYLON.Color3(0.6, 0.9, 1) },
  { name: "Neptune", distance: 490, speed: 0.54, size: 8, color: new BABYLON.Color3(0.3, 0.4, 1) },
  { name: "Pluto", distance: 560, speed: 0.47, size: 2.5, color: new BABYLON.Color3(0.8, 0.8, 0.8) }
];

planetsData.forEach(p => {
  const mesh = BABYLON.MeshBuilder.CreateSphere(p.name, { diameter: p.size }, scene);
  const mat = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
  mat.diffuseColor = p.color;
  mesh.material = mat;

  scene.registerBeforeRender(() => {
    const t = performance.now() * 0.00001 * p.speed * timeFactor;
    mesh.position.x = Math.cos(t) * p.distance;
    mesh.position.z = Math.sin(t) * p.distance;
    mesh.position.y = 0;
  });

  if (p.name === "Saturn") {
    const ring = BABYLON.MeshBuilder.CreateDisc("SaturnRing", {
      radius: p.size * 2.5,
      tessellation: 64,
      arc: 1
    }, scene);
    const ringMat = new BABYLON.StandardMaterial("SaturnRingMat", scene);
    ringMat.diffuseColor = new BABYLON.Color3(0.8, 0.7, 0.5);
    ringMat.alpha = 0.4;
    ring.material = ringMat;
    ring.rotation.x = Math.PI / 3;
    ring.parent = mesh;
  }
});
</script>
<script>
planetsData.forEach(p => {
  const orbit = BABYLON.MeshBuilder.CreateTorus(`${p.name}_orbit`, {
    diameter: p.distance * 2,
    thickness: 0.15,
    tessellation: 100
  }, scene);
  const orbitMat = new BABYLON.StandardMaterial(`${p.name}_orbit_mat`, scene);
  orbitMat.emissiveColor = new BABYLON.Color3(0.2, 0.6, 0.8);
  orbit.material = orbitMat;
  orbit.rotation.x = Math.PI / 2;
});
</script>
<script>
for (let i = 0; i < 300; i++) {
  const angle = Math.random() * Math.PI * 2;
  const radius = 260 + Math.random() * 60;
  const height = (Math.random() - 0.5) * 8;
  const rock = BABYLON.MeshBuilder.CreateSphere(`asteroid_${i}`, { diameter: 0.8 }, scene);
  const mat = new BABYLON.StandardMaterial(`asteroidMat_${i}`, scene);
  mat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.3);
  rock.material = mat;
  rock.position.set(
    Math.cos(angle) * radius,
    height,
    Math.sin(angle) * radius
  );
}
</script>
<script>
const comet = BABYLON.MeshBuilder.CreateSphere("Comet", { diameter: 2 }, scene);
const cometMat = new BABYLON.StandardMaterial("cometMat", scene);
cometMat.emissiveColor = new BABYLON.Color3(0.9, 0.9, 1);
comet.material = cometMat;

const cometTrail = new BABYLON.TrailMesh("cometTrail", comet, scene, 60, 1.2, true);
const trailMat = new BABYLON.StandardMaterial("cometTrailMat", scene);
trailMat.emissiveColor = new BABYLON.Color3(0.5, 0.8, 1);
cometTrail.material = trailMat;

scene.registerBeforeRender(() => {
  const t = performance.now() * 0.00002 * timeFactor;
  comet.position.x = Math.sin(t) * 700;
  comet.position.z = Math.cos(t * 0.8) * 500;
  comet.position.y = Math.sin(t * 0.5) * 80;
});
</script>
<script>
const stellarSystems = [
  {
    name: "Proxima Centauri",
    pos: new BABYLON.Vector3(-5000, 0, 9000),
    color: new BABYLON.Color3(1, 0.5, 0.5),
    planets: [{ name: "Proxima b", dist: 40, size: 3, speed: 0.5 }]
  },
  {
    name: "Alpha Centauri",
    pos: new BABYLON.Vector3(8000, 0, -6000),
    color: new BABYLON.Color3(1, 1, 0.7),
    planets: []
  },
  {
    name: "Kepler-186",
    pos: new BABYLON.Vector3(12000, 0, 12000),
    color: new BABYLON.Color3(0.7, 0.9, 1),
    planets: [{ name: "Kepler-186f", dist: 30, size: 2.8, speed: 0.6 }]
  }
];

stellarSystems.forEach(sys => {
  const star = BABYLON.MeshBuilder.CreateSphere(`${sys.name}_star`, { diameter: 20 }, scene);
  const mat = new BABYLON.StandardMaterial(`${sys.name}_mat`, scene);
  mat.emissiveColor = sys.color;
  star.material = mat;
  star.position = sys.pos;

  sys.planets.forEach((p, i) => {
    const planet = BABYLON.MeshBuilder.CreateSphere(`${sys.name}_${p.name}`, { diameter: p.size }, scene);
    const pm = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
    pm.diffuseColor = BABYLON.Color3.Random();
    planet.material = pm;

    scene.registerBeforeRender(() => {
      const angle = performance.now() * 0.00001 * p.speed * timeFactor + i;
      planet.position.x = sys.pos.x + Math.cos(angle) * p.dist;
      planet.position.z = sys.pos.z + Math.sin(angle) * p.dist;
      planet.position.y = sys.pos.y;
    });
  });
});
</script>
<script>
function jumpToSystem(name) {
  const sys = stellarSystems.find(s => s.name === name);
  if (!sys) return;
  followPlanet = null;

  const animTarget = new BABYLON.Animation("camToStar", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
  animTarget.setKeys([
    { frame: 0, value: camera.target.clone() },
    { frame: 120, value: sys.pos.clone() }
  ]);

  const animZoom = new BABYLON.Animation("camZoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
  animZoom.setKeys([
    { frame: 0, value: camera.radius },
    { frame: 120, value: 400 }
  ]);

  camera.animations = [animTarget, animZoom];
  scene.beginAnimation(camera, 0, 120, false);

  if (window.speechSynthesis) {
    const msg = new SpeechSynthesisUtterance(`Jumping to ${sys.name}`);
    msg.lang = "en-US";
    speechSynthesis.speak(msg);
  }
}

addButton("ðŸŒŒ Stellar Neighborhood", () => {
  const popup = new BABYLON.GUI.StackPanel();
  popup.width = "200px";
  popup.height = "auto";
  popup.background = "rgba(0,0,0,0.8)";
  popup.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
  popup.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
  gui.addControl(popup);

  stellarSystems.forEach(sys => {
    const btn = BABYLON.GUI.Button.CreateSimpleButton(`btn_${sys.name}`, `â†— ${sys.name}`);
    btn.height = "30px";
    btn.color = "violet";
    btn.background = "transparent";
    btn.onPointerClickObservable.add(() => {
      jumpToSystem(sys.name);
      gui.removeControl(popup);
    });
    popup.addControl(btn);
  });
});
</script>
<script>
const copilotFacts = [
  "Neptune's winds exceed 1,200 mph.",
  "Jupiterâ€™s Great Red Spot is a storm twice Earthâ€™s size.",
  "Light takes over 4 years to reach us from Alpha Centauri.",
  "Saturn's rings are mostly ice chunks and rock debris.",
  "Proxima b is in the habitable zone of its star."
];

function showCopilotFact() {
  const msg = copilotFacts[Math.floor(Math.random() * copilotFacts.length)];

  const bubble = new BABYLON.GUI.Rectangle("copilotBubble");
  bubble.width = "280px";
  bubble.height = "90px";
  bubble.cornerRadius = 10;
  bubble.color = "white";
  bubble.thickness = 1;
  bubble.background = "rgba(10,10,10,0.85)";
  bubble.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
  bubble.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
  bubble.top = "20px";
  bubble.right = "20px";

  const text = new BABYLON.GUI.TextBlock();
  text.text = msg;
  text.color = "#A0E0FF";
  text.fontSize = 14;
  text.textWrapping = true;
  bubble.addControl(text);
  gui.addControl(bubble);

  if (window.speechSynthesis) {
    const utter = new SpeechSynthesisUtterance(msg);
    utter.lang = "en-US";
    speechSynthesis.speak(utter);
  }

  setTimeout(() => gui.removeControl(bubble), 8000);
}

setInterval(showCopilotFact, 180000); // Every 3 minutes
</script>
<script>
// Lunar Landings (Apollo flags on Moon)
const moon = scene.getMeshByName("Moon") || scene.getMeshByName("Earth");
const landingSites = [
  { name: "Apollo 11", lat: 0.674, lon: 23.472 },
  { name: "Apollo 12", lat: -3.012, lon: -23.421 },
  { name: "Apollo 17", lat: 20.1908, lon: 30.7717 }
];

landingSites.forEach(site => {
  const latRad = BABYLON.Tools.ToRadians(site.lat);
  const lonRad = BABYLON.Tools.ToRadians(site.lon);
  const r = moon.getBoundingInfo().boundingSphere.radius * 1.02;
  const x = r * Math.cos(latRad) * Math.cos(lonRad);
  const y = r * Math.sin(latRad);
  const z = r * Math.cos(latRad) * Math.sin(lonRad);

  const flag = BABYLON.MeshBuilder.CreateBox(site.name, { size: 1 }, scene);
  const mat = new BABYLON.StandardMaterial(`${site.name}_mat`, scene);
  mat.emissiveColor = new BABYLON.Color3(1, 0.2, 0.2);
  flag.material = mat;
  flag.position.set(x, y, z);
  flag.parent = moon;

  flag.actionManager = new BABYLON.ActionManager(scene);
  flag.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
    BABYLON.ActionManager.OnPickTrigger,
    () => speechSynthesis?.speak(new SpeechSynthesisUtterance(`${site.name} landing site.`))
  ));
});

// Surface Maps
addButton("ðŸ—º Surface Maps", () => {
  const maps = {
    Earth: "earth_topo_map.jpg",
    Mars: "mars_topo_map.jpg",
    Moon: "moon_map.jpg"
  };
  Object.keys(maps).forEach(name => {
    const p = scene.getMeshByName(name);
    if (p) {
      const mat = new BABYLON.StandardMaterial(`${name}_surf`, scene);
      mat.diffuseTexture = new BABYLON.Texture(maps[name], scene);
      mat.specularColor = BABYLON.Color3.Black();
      p.material = mat;
    }
  });
});

// Tour
const tourSequence = [...planetsData.map(p => p.name), ...stellarSystems.map(s => s.name)];
let tourIndex = 0;

function startCinematicTour() {
  if (tourIndex >= tourSequence.length) tourIndex = 0;
  const name = tourSequence[tourIndex++];
  const obj = scene.getMeshByName(name);
  if (!obj) return;
  followPlanet = null;

  const animTarget = new BABYLON.Animation("tourTarget", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
  animTarget.setKeys([{ frame: 0, value: camera.target.clone() }, { frame: 90, value: obj.position.clone() }]);

  const animZoom = new BABYLON.Animation("tourZoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
  animZoom.setKeys([{ frame: 0, value: camera.radius }, { frame: 90, value: 100 }]);

  camera.animations = [animTarget, animZoom];
  scene.beginAnimation(camera, 0, 90, false);
  speechSynthesis?.speak(new SpeechSynthesisUtterance(`Now approaching ${name}`));
  setTimeout(startCinematicTour, 7000);
}

addButton("ðŸŽ¥ Start Tour", startCinematicTour);

// Time-Lapse Recorder
let isRecording = false;
const frames = [];

addButton("âº Start Recording", () => {
  isRecording = true;
  frames.length = 0;
  speechSynthesis?.speak(new SpeechSynthesisUtterance("Recording started."));
});

addButton("â¹ Stop & Download", () => {
  isRecording = false;
  speechSynthesis?.speak(new SpeechSynthesisUtterance("Exporting frames."));
  frames.forEach((data, i) => {
    const a = document.createElement("a");
    a.href = data;
    a.download = `frame_${i}.png`;
    a.click();
  });
});

scene.registerAfterRender(() => {
  if (isRecording) frames.push(canvas.toDataURL("image/png"));
});

// Meteor Shower
function triggerMeteorShower() {
  const meteors = [];
  for (let i = 0; i < 40; i++) {
    const m = BABYLON.MeshBuilder.CreateSphere(`meteor_${i}`, { diameter: 0.4 }, scene);
    const mat = new BABYLON.StandardMaterial(`meteorMat_${i}`, scene);
    mat.emissiveColor = new BABYLON.Color3(1, 0.5, 0.2);
    mat.alpha = 0.6;
    m.material = mat;
    const start = new BABYLON.Vector3(Math.random()*800-400, 150+Math.random()*100, Math.random()*800-400);
    m.position = start;
    const dir = new BABYLON.Vector3(-1, -1.2, 0).normalize().scale(3+Math.random()*2);
    meteors.push({ mesh: m, dir, age: 0 });
  }
  scene.registerBeforeRender(() => {
    meteors.forEach(m => {
      if (m.mesh) {
        m.mesh.position.addInPlace(m.dir);
        if (++m.age > 100) {
          m.mesh.dispose();
          m.mesh = null;
        }
      }
    });
  });
}

const d = new Date();
if (d.getMonth() === 7 && d.getDate() >= 10 && d.getDate() <= 15) {
  triggerMeteorShower();
  speechSynthesis?.speak(new SpeechSynthesisUtterance("Perseid meteor shower active this week."));
}

// Zoom In / Out buttons + hotkeys
addButton("ðŸ” Zoom In [X]", () => camera.radius *= 0.7);
addButton("ðŸ”Ž Zoom Out [Z]", () => camera.radius *= 1.5);

window.addEventListener("keydown", e => {
  const key = e.key.toLowerCase();
  if (key === "x") camera.radius *= 0.7;
  if (key === "z") camera.radius *= 1.5;
});

// Time Controls
addButton("â¯ Pause", () => timeFactor = 0);
addButton("â© Time x2", () => timeFactor = 2);
addButton("â© Time x10", () => timeFactor = 10);
addButton("â© Time x100", () => timeFactor = 100);

// Target Tracker
const targetLabel = new BABYLON.GUI.TextBlock();
targetLabel.text = "";
targetLabel.color = "aqua";
targetLabel.fontSize = 16;
targetLabel.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
targetLabel.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
targetLabel.top = "-30px";
gui.addControl(targetLabel);

scene.registerBeforeRender(() => {
  targetLabel.text = followPlanet?.name ? `ðŸŽ¯ Target: ${followPlanet.name}` : "";
});

// Help overlay [?] and debug toggle
const helpOverlay = new BABYLON.GUI.Rectangle();
helpOverlay.width = "500px";
helpOverlay.height = "200px";
helpOverlay.cornerRadius = 10;
helpOverlay.color = "white";
helpOverlay.background = "rgba(0,0,0,0.9)";
helpOverlay.thickness = 2;
helpOverlay.isVisible = false;
helpOverlay.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
helpOverlay.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
gui.addControl(helpOverlay);

const helpText = new BABYLON.GUI.TextBlock();
helpText.text = `ðŸ•¹ Controls:
W/A/S/D â€“ Move â€¢ Mouse â€“ Orbit
Z â€“ Zoom out â€¢ X â€“ Zoom in
? â€“ Toggle help â€¢ Shift+D â€“ Debug`;
helpText.color = "#A0E0FF";
helpText.fontSize = 16;
helpText.textWrapping = true;
helpOverlay.addControl(helpText);

window.addEventListener("keydown", e => {
  if (e.key === "?") helpOverlay.isVisible = !helpOverlay.isVisible;
  if (e.shiftKey && e.key.toLowerCase() === "d") {
    scene.debugLayer.isVisible() ? scene.debugLayer.hide() : scene.debugLayer.show();
  }
});

// Save/restore camera
window.addEventListener("beforeunload", () => {
  localStorage.setItem("cameraTarget", JSON.stringify(camera.target));
  localStorage.setItem("cameraRadius", camera.radius);
// Restore camera from localStorage
window.addEventListener("DOMContentLoaded", () => {
  const target = localStorage.getItem("cameraTarget");
  const radius = localStorage.getItem("cameraRadius");
  if (target) camera.setTarget(BABYLON.Vector3.FromArray(JSON.parse(target)));
  if (radius) camera.radius = parseFloat(radius);

  // Splash screen fade
  setTimeout(() => {
    const splash = document.getElementById("splash-screen");
    if (splash) {
      splash.style.transition = "opacity 1s ease";
      splash.style.opacity = 0;
      setTimeout(() => splash.remove(), 1000);
    }
  }, 1000);
});

// Render loop
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());

// Service worker (optional)
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("sw.js")
    .then(() => console.log("âœ… Service Worker registered"))
    .catch(err => console.warn("Service Worker error0:", err));
}
</script>
</body>
</html>
