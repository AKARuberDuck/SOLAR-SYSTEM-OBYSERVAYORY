<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Galactic Observatory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="favicon.png" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      background: black;
      font-family: 'Segoe UI', sans-serif;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #splash-screen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    #splash-screen img {
      max-width: 80%;
      max-height: 80%;
      opacity: 0.9;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>
<body>
  <div id="splash-screen">
    <img src="splash-loading-screen.png" alt="Loading Galactic Observatory..." />
  </div>
  <canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = BABYLON.Color3.Black();

const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI/2, Math.PI/2.2, 2500, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 20;

const light = new BABYLON.PointLight("sunLight", new BABYLON.Vector3(0, 0, 0), scene);
light.intensity = 2.5;

const starfield = new BABYLON.Layer("starfield", "8k_stars_milky_way.jpg", scene, true);

const sun = BABYLON.MeshBuilder.CreateSphere("Sun", { diameter: 18 }, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveColor = new BABYLON.Color3(1, 0.85, 0.2);
sun.material = sunMat;

const glowLayer = new BABYLON.GlowLayer("glow", scene);
function createPlanet(name, size, dist, speed, color, moons = []) {
  const planet = BABYLON.MeshBuilder.CreateSphere(name, { diameter: size }, scene);
  const mat = new BABYLON.StandardMaterial(name + "_mat", scene);
  mat.diffuseColor = color;
  planet.material = mat;

  let angle = Math.random() * Math.PI * 2;
  scene.registerBeforeRender(() => {
    angle += speed * timeFactor;
    planet.position.x = Math.cos(angle) * dist;
    planet.position.z = Math.sin(angle) * dist;
  });

  const label = BABYLON.MeshBuilder.CreatePlane(name + "_label", { size: 8 }, scene);
  label.parent = planet;
  label.position.y = size + 2;
  const labelTex = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(label);
  const text = new BABYLON.GUI.TextBlock();
  text.text = name;
  text.color = "white";
  text.fontSize = 24;
  labelTex.addControl(text);

  moons.forEach((moon, i) => {
    const m = BABYLON.MeshBuilder.CreateSphere(`${name}_moon_${i}`, { diameter: moon.size }, scene);
    const moonMat = new BABYLON.StandardMaterial(`${name}_moonMat_${i}`, scene);
    moonMat.diffuseColor = moon.color;
    m.material = moonMat;

    let mAngle = Math.random() * Math.PI * 2;
    scene.registerBeforeRender(() => {
      mAngle += moon.speed * timeFactor;
      m.position.x = planet.position.x + Math.cos(mAngle) * moon.distance;
      m.position.z = planet.position.z + Math.sin(mAngle) * moon.distance;
    });
  });

  planet.actionManager = new BABYLON.ActionManager(scene);
  planet.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
    BABYLON.ActionManager.OnPickTrigger,
    () => showPlanetInfo(name)
  ));

  return planet;
}
const moveKeys = { forward: false, back: false, left: false, right: false };
scene.onKeyboardObservable.add((kbInfo) => {
  const pressed = kbInfo.type === BABYLON.KeyboardEventTypes.KEYDOWN;
  const key = kbInfo.event.key.toLowerCase();
  switch (key) {
    case 'w':
    case 'arrowup':    moveKeys.forward = pressed; break;
    case 's':
    case 'arrowdown':  moveKeys.back = pressed; break;
    case 'a':
    case 'arrowleft':  moveKeys.left = pressed; break;
    case 'd':
    case 'arrowright': moveKeys.right = pressed; break;
  }
});

window.addEventListener("keydown", (e) => {
  const key = e.key.toLowerCase();
  if (key === "f") {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
    } else {
      document.exitFullscreen();
    }
  } else if (key === "z") {
    camera.setTarget(BABYLON.Vector3.Zero());
    camera.radius = 2500;
  } else if (key === "x" && camera.radius > camera.lowerRadiusLimit + 10) {
    camera.radius *= 0.9;
  }
});
engine.runRenderLoop(() => {
  const speed = 5;
  const direction = new BABYLON.Vector3(
    (moveKeys.right ? 1 : 0) - (moveKeys.left ? 1 : 0),
    0,
    (moveKeys.back ? 1 : 0) - (moveKeys.forward ? 1 : 0)
  );
  if (!direction.equals(BABYLON.Vector3.Zero())) {
    const transformed = BABYLON.Vector3.TransformCoordinates(direction, BABYLON.Matrix.RotationY(camera.alpha));
    camera.target.addInPlace(transformed.scale(speed));
  }

  scene.render();
});

window.addEventListener("resize", () => {
  engine.resize();
});
</script>
</body>
</html>
