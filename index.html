<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar Observatory Plus</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="favicon.ico" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: black;
      font-family: 'Segoe UI', sans-serif;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #splash-screen {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background-color: black;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #splash-screen img {
      max-width: 80%;
      opacity: 0.8;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <div id="splash-screen">
    <img src="splash-loading-screen.png" alt="Loading..." />
  </div>
  <canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color3.Black();

const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.2, 2500, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 20;
camera.upperRadiusLimit = 10000;

const light = new BABYLON.PointLight("SunLight", BABYLON.Vector3.Zero(), scene);
light.intensity = 2.5;

const glowLayer = new BABYLON.GlowLayer("glow", scene);
const starfield = new BABYLON.Layer("starfield", "8k_stars_milky_way.jpg", scene, true);

let timeFactor = 1;
</script>
<script>
// Sun visual
const sun = BABYLON.MeshBuilder.CreateSphere("Sun", { diameter: 30 }, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveColor = new BABYLON.Color3(1, 0.8, 0.1);
sunMat.disableLighting = true;
sun.material = sunMat;
sun.position = BABYLON.Vector3.Zero();
</script>
<script>
const planetsData = [
  { name: "Mercury", distance: 80, speed: 4.8, size: 4, color: new BABYLON.Color3(0.5, 0.5, 0.5) },
  { name: "Venus", distance: 120, speed: 3.5, size: 5.5, color: new BABYLON.Color3(0.9, 0.7, 0.3) },
  { name: "Earth", distance: 160, speed: 2.98, size: 6, color: new BABYLON.Color3(0.4, 0.6, 1) },
  { name: "Mars", distance: 210, speed: 2.4, size: 5, color: new BABYLON.Color3(1, 0.4, 0.3) },
  { name: "Jupiter", distance: 280, speed: 1.3, size: 12, color: new BABYLON.Color3(0.8, 0.6, 0.4) },
  { name: "Saturn", distance: 360, speed: 0.96, size: 10, color: new BABYLON.Color3(1, 0.9, 0.6) },
  { name: "Uranus", distance: 430, speed: 0.68, size: 8, color: new BABYLON.Color3(0.6, 0.9, 1) },
  { name: "Neptune", distance: 490, speed: 0.54, size: 8, color: new BABYLON.Color3(0.3, 0.4, 1) },
  { name: "Pluto", distance: 560, speed: 0.47, size: 2.5, color: new BABYLON.Color3(0.8, 0.8, 0.8) }
];

planetsData.forEach(p => {
  const planet = BABYLON.MeshBuilder.CreateSphere(p.name, { diameter: p.size }, scene);
  const mat = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
  mat.diffuseColor = p.color;
  planet.material = mat;

  // Animate orbit
  scene.registerBeforeRender(() => {
    const angle = performance.now() * 0.00001 * p.speed * timeFactor;
    planet.position.x = Math.cos(angle) * p.distance;
    planet.position.z = Math.sin(angle) * p.distance;
  });

  // Add rings to Saturn
  if (p.name === "Saturn") {
    const ring = BABYLON.MeshBuilder.CreateDisc("SaturnRing", {
      radius: p.size * 2,
      tessellation: 64,
      arc: 1
    }, scene);
    const ringMat = new BABYLON.StandardMaterial("SaturnRingMat", scene);
    ringMat.diffuseColor = new BABYLON.Color3(0.8, 0.7, 0.5);
    ringMat.alpha = 0.4;
    ring.material = ringMat;
    ring.rotation.x = Math.PI / 3;
    ring.parent = planet;
  }
});
</script>
<script>
planetsData.forEach(p => {
  const orbit = BABYLON.MeshBuilder.CreateTorus(`${p.name}_orbit`, {
    diameter: p.distance * 2,
    thickness: 0.15,
    tessellation: 100
  }, scene);

  const orbitMat = new BABYLON.StandardMaterial(`${p.name}_orbit_mat`, scene);
  orbitMat.emissiveColor = new BABYLON.Color3(0.2, 0.6, 0.8);
  orbit.material = orbitMat;
  orbit.rotation.x = Math.PI / 2;
});
</script>
<script>
const asteroidCount = 350;
for (let i = 0; i < asteroidCount; i++) {
  const angle = Math.random() * Math.PI * 2;
  const radius = 260 + Math.random() * 80;
  const height = (Math.random() - 0.5) * 10;

  const rock = BABYLON.MeshBuilder.CreateSphere(`asteroid_${i}`, { diameter: 0.9 }, scene);
  const mat = new BABYLON.StandardMaterial(`asteroidMat_${i}`, scene);
  mat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.3);
  rock.material = mat;

  rock.position.set(
    Math.cos(angle) * radius,
    height,
    Math.sin(angle) * radius
  );
}
</script>
<script>
// Create comet body
const comet = BABYLON.MeshBuilder.CreateSphere("Comet", { diameter: 2 }, scene);
const cometMat = new BABYLON.StandardMaterial("cometMat", scene);
cometMat.emissiveColor = new BABYLON.Color3(0.9, 0.9, 1);
comet.material = cometMat;

// Create comet tail with trail mesh
const cometTrail = new BABYLON.TrailMesh("cometTrail", comet, scene, 60, 1.2, true);
const trailMat = new BABYLON.StandardMaterial("cometTrailMat", scene);
trailMat.emissiveColor = new BABYLON.Color3(0.5, 0.8, 1);
cometTrail.material = trailMat;

// Move comet dynamically through the solar system
scene.registerBeforeRender(() => {
  const t = performance.now() * 0.00002 * timeFactor;
  comet.position.x = Math.sin(t) * 700;
  comet.position.z = Math.cos(t * 0.8) * 500;
  comet.position.y = Math.sin(t * 0.5) * 80;
});
</script>
<script>
const stellarSystems = [
  {
    name: "Proxima Centauri",
    pos: new BABYLON.Vector3(-5000, 0, 9000),
    color: new BABYLON.Color3(1, 0.5, 0.5),
    planets: [
      { name: "Proxima b", dist: 40, size: 3, speed: 0.5 }
    ]
  },
  {
    name: "Alpha Centauri",
    pos: new BABYLON.Vector3(8000, 0, -6000),
    color: new BABYLON.Color3(1, 1, 0.7),
    planets: []
  },
  {
    name: "Kepler-186",
    pos: new BABYLON.Vector3(12000, 0, 12000),
    color: new BABYLON.Color3(0.7, 0.9, 1),
    planets: [
      { name: "Kepler-186f", dist: 30, size: 2.8, speed: 0.6 }
    ]
  }
];

// Add distant stars with glow
stellarSystems.forEach(sys => {
  const star = BABYLON.MeshBuilder.CreateSphere(`${sys.name}_star`, { diameter: 20 }, scene);
  const starMat = new BABYLON.StandardMaterial(`${sys.name}_mat`, scene);
  starMat.emissiveColor = sys.color;
  star.material = starMat;
  star.position = sys.pos;

  sys.planets.forEach((p, i) => {
    const planet = BABYLON.MeshBuilder.CreateSphere(`${sys.name}_${p.name}`, { diameter: p.size }, scene);
    const mat = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
    mat.diffuseColor = BABYLON.Color3.Random();
    planet.material = mat;

    scene.registerBeforeRender(() => {
      const angle = performance.now() * 0.00001 * p.speed * timeFactor;
      planet.position.x = sys.pos.x + Math.cos(angle + i) * p.dist;
      planet.position.z = sys.pos.z + Math.sin(angle + i) * p.dist;
      planet.position.y = sys.pos.y;
    });
  });
});
</script>
<script>
// Jump camera between systems
function jumpToSystem(name) {
  const sys = stellarSystems.find(s => s.name === name);
  if (!sys) return;

  followPlanet = null;
  const animTarget = new BABYLON.Animation("camToStar", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
  animTarget.setKeys([
    { frame: 0, value: camera.target.clone() },
    { frame: 120, value: sys.pos.clone() }
  ]);

  const animZoom = new BABYLON.Animation("camZoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
  animZoom.setKeys([
    { frame: 0, value: camera.radius },
    { frame: 120, value: 400 }
  ]);

  camera.animations = [animTarget, animZoom];
  scene.beginAnimation(camera, 0, 120, false);

  maybeSpeak(`Jumping to ${sys.name}.`);
}

// GUI button
addButton("🌌 Stellar Neighborhood", () => {
  planetPanel.clearControls();
  stellarSystems.forEach(s => {
    const btn = BABYLON.GUI.Button.CreateSimpleButton(`btn_${s.name}`, s.name);
    btn.height = "30px";
    btn.color = "violet";
    btn.background = "rgba(40,40,80,0.7)";
    btn.onPointerClickObservable.add(() => {
      jumpToSystem(s.name);
    });
    planetPanel.addControl(btn);
  });
  planetPanel.isVisible = true;
});
</script>
<script>
function generateMoons(parentName, count) {
  const parent = scene.getMeshByName(parentName);
  if (!parent) return;

  for (let i = 0; i < count; i++) {
    const moon = BABYLON.MeshBuilder.CreateSphere(`${parentName}_moon_${i}`, { diameter: 1.2 }, scene);
    const mat = new BABYLON.StandardMaterial(`moonMat_${i}`, scene);
    mat.emissiveColor = new BABYLON.Color3(0.6, 0.6, 0.7);
    moon.material = mat;

    const radius = 10 + i * 4;
    const speed = 0.3 + Math.random() * 0.5;
    const offset = Math.random() * Math.PI * 2;

    scene.registerBeforeRender(() => {
      const angle = performance.now() * 0.00002 * speed * timeFactor + offset;
      moon.position.x = parent.position.x + Math.cos(angle) * radius;
      moon.position.z = parent.position.z + Math.sin(angle) * radius;
      moon.position.y = parent.position.y;
    });
  }
}

// Automatically generate moons for gas giants
["Jupiter", "Saturn", "Uranus", "Neptune"].forEach(p => generateMoons(p, 3));
</script>
<script>
function triggerMeteorShower() {
  const meteors = [];
  for (let i = 0; i < 40; i++) {
    const streak = BABYLON.MeshBuilder.CreateSphere(`meteor_${i}`, { diameter: 0.4 }, scene);
    const mat = new BABYLON.StandardMaterial(`meteorMat_${i}`, scene);
    mat.emissiveColor = new BABYLON.Color3(1, 0.5, 0.2);
    mat.alpha = 0.6;
    streak.material = mat;

    const start = new BABYLON.Vector3(
      Math.random() * 600 - 300,
      200 + Math.random() * 100,
      Math.random() * 600 - 300
    );

    const dir = new BABYLON.Vector3(-1, -1.5, 0).normalize().scale(4 + Math.random() * 3);
    streak.position = start;
    meteors.push({ mesh: streak, dir, age: 0 });
  }

  scene.registerBeforeRender(() => {
    meteors.forEach(m => {
      m.mesh.position.addInPlace(m.dir);
      m.age++;
      if (m.age > 100) m.mesh.dispose();
    });
  });
}

// Trigger during Perseids: Aug 10–15
const today = new Date();
if (today.getMonth() === 7 && today.getDate() >= 10 && today.getDate() <= 15) {
  triggerMeteorShower();
  maybeSpeak("Welcome to the Perseid meteor shower.");
}
</script>
<script>
function fetchLaunches() {
  fetch("https://ll.thespacedevs.com/2.2.0/launch/upcoming/?limit=3")
    .then(res => res.json())
    .then(data => {
      const launches = data.results.map(l => `${l.name} — ${new Date(l.window_start).toLocaleString()}`);
      const launchText = launches.join("\n");

      const launchHUD = new BABYLON.GUI.TextBlock();
      launchHUD.text = "🚀 Upcoming Launches:\n" + launchText;
      launchHUD.color = "white";
      launchHUD.fontSize = 14;
      launchHUD.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
      launchHUD.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
      launchHUD.paddingTop = 20;
      launchHUD.paddingLeft = 20;
      launchHUD.width = "30%";
      gui.addControl(launchHUD);

      maybeSpeak("Space launches incoming. Check the top-left for countdowns.");
    }).catch(err => console.warn("Launch API failed:", err));
}

fetchLaunches();
</script>
<script>
const copilotFacts = [
  "Did you know Neptune has supersonic winds up to 1,200 mph?",
  "You're now orbiting through one of over 1 million known asteroids.",
  "Pluto was reclassified as a dwarf planet in 2006.",
  "Time here slows down near massive bodies like Jupiter.",
  "Solar flares release energy equivalent to millions of nuclear bombs!"
];

function showCopilotFact() {
  const msg = copilotFacts[Math.floor(Math.random() * copilotFacts.length)];

  const bubble = new BABYLON.GUI.Rectangle("copilotBubble");
  bubble.width = "250px";
  bubble.height = "80px";
  bubble.cornerRadius = 10;
  bubble.color = "white";
  bubble.thickness = 1;
  bubble.background = "rgba(10,10,10,0.85)";
  bubble.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
  bubble.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
  bubble.top = "20px";
  bubble.right = "20px";

  const text = new BABYLON.GUI.TextBlock();
  text.text = msg;
  text.color = "#A0E0FF";
  text.fontSize = 14;
  text.textWrapping = true;
  bubble.addControl(text);

  gui.addControl(bubble);
  maybeSpeak(msg);

  setTimeout(() => gui.removeControl(bubble), 8000);
}

// Trigger tooltip every few minutes
setInterval(showCopilotFact, 180000);
</script>
  <script>
const speedHUD = new BABYLON.GUI.TextBlock();
speedHUD.text = "";
speedHUD.color = "lightgreen";
speedHUD.fontSize = 16;
speedHUD.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
speedHUD.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
speedHUD.top = "40px";
gui.addControl(speedHUD);

scene.registerBeforeRender(() => {
  const speed = Math.abs(timeFactor);
  if (speed >= 1000) {
    const dilation = 1 / Math.sqrt(1 - Math.pow(speed / 299792, 2)); // C = 299,792 km/s
    speedHUD.text = `⚠ Time Dilation: 1s here ≈ ${dilation.toFixed(2)}s on Earth`;
  } else {
    speedHUD.text = "";
  }
});
</script>
<script>
const moon = scene.getMeshByName("Moon") || scene.getMeshByName("Earth"); // fallback if Moon not distinct
const landingSites = [
  { name: "Apollo 11", lat: 0.674, lon: 23.472 },
  { name: "Apollo 12", lat: -3.012, lon: -23.421 },
  { name: "Apollo 17", lat: 20.1908, lon: 30.7717 }
];

landingSites.forEach(site => {
  const latRad = BABYLON.Tools.ToRadians(site.lat);
  const lonRad = BABYLON.Tools.ToRadians(site.lon);
  const radius = moon.getBoundingInfo().boundingSphere.radius * 1.02;

  const x = radius * Math.cos(latRad) * Math.cos(lonRad);
  const y = radius * Math.sin(latRad);
  const z = radius * Math.cos(latRad) * Math.sin(lonRad);

  const marker = BABYLON.MeshBuilder.CreateBox(`${site.name}_flag`, { size: 1 }, scene);
  const mat = new BABYLON.StandardMaterial(`${site.name}_mat`, scene);
  mat.emissiveColor = new BABYLON.Color3(0.9, 0.2, 0.2);
  marker.material = mat;
  marker.position.set(x, y, z);

  marker.parent = moon;

  marker.actionManager = new BABYLON.ActionManager(scene);
  marker.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
    maybeSpeak(`${site.name} landing site. Welcome to lunar history.`);
  }));
});
</script>
<script>
const tourTargets = [...planetsData.map(p => p.name), ...stellarSystems.map(s => s.name)];
let tourIndex = 0;

function startTour() {
  if (tourIndex >= tourTargets.length) tourIndex = 0;
  const name = tourTargets[tourIndex++];
  const obj = scene.getMeshByName(name);
  if (!obj) return;
  followPlanet = null;

  const animTarget = new BABYLON.Animation("camTour", "target", 60, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
  animTarget.setKeys([
    { frame: 0, value: camera.target.clone() },
    { frame: 90, value: obj.position.clone() }
  ]);

  const animZoom = new BABYLON.Animation("camTourZoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
  animZoom.setKeys([
    { frame: 0, value: camera.radius },
    { frame: 90, value: 100 }
  ]);

  camera.animations = [animTarget, animZoom];
  scene.beginAnimation(camera, 0, 90, false);
  maybeSpeak(`Now approaching ${name}.`);

  setTimeout(startTour, 6000);
}

addButton("🎥 Start Tour", () => {
  tourIndex = 0;
  startTour();
});
</script>
<script>
const mapTextures = {
  Earth: "earth_topo_map.jpg",
  Mars: "mars_topo_map.jpg",
  Moon: "moon_map.jpg"
};

addButton("🗺 Toggle Surface Maps", () => {
  ["Earth", "Mars", "Moon"].forEach(name => {
    const planet = scene.getMeshByName(name);
    if (!planet) return;
    const mat = new BABYLON.StandardMaterial(`${name}_map`, scene);
    mat.diffuseTexture = new BABYLON.Texture(mapTextures[name], scene);
    mat.specularColor = BABYLON.Color3.Black();
    planet.material = mat;
  });
  maybeSpeak("Surface maps activated.");
});
</script>
<script>
let isRecording = false;
const canvasFrames = [];

addButton("⏺ Start Time-Lapse", () => {
  isRecording = true;
  canvasFrames.length = 0;
  maybeSpeak("Recording started.");
});

addButton("⏹ Stop & Export", () => {
  isRecording = false;
  maybeSpeak("Recording stopped. Downloading frames.");
  canvasFrames.forEach((frame, i) => {
    const a = document.createElement("a");
    a.href = frame;
    a.download = `frame_${i}.png`;
    a.click();
  });
});

scene.registerAfterRender(() => {
  if (isRecording) {
    const dataURL = canvas.toDataURL("image/png");
    canvasFrames.push(dataURL);
  }
});
</script>
