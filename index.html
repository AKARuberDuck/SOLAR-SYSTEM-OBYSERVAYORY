<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Galactic Observatory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="favicon.png" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      height: 100%; width: 100%; background: black;
    }
    canvas {
      width: 100%; height: 100%; display: block;
    }
    #splash-screen {
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    #splash-screen img {
      max-width: 80%;
      max-height: 80%;
      opacity: 0.85;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
</head>
<body>
  <div id="splash-screen">
    <img src="splash-loading-screen.png" alt="Loading Galactic Observatory..." />
  </div>
  <canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = BABYLON.Color3.Black();

const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI/2, Math.PI/2.2, 2500, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 20;

const light = new BABYLON.PointLight("sunLight", BABYLON.Vector3.Zero(), scene);
light.intensity = 2.5;

const starfield = new BABYLON.Layer("starfield", "8k_stars_milky_way.jpg", scene, true);

const sun = BABYLON.MeshBuilder.CreateSphere("Sun", { diameter: 18 }, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveColor = new BABYLON.Color3(1, 0.85, 0.2);
sun.material = sunMat;

const glowLayer = new BABYLON.GlowLayer("glow", scene);
let timeFactor = 1;
</script>
<script>
function createPlanet(name, size, dist, speed, color, moons = []) {
  const p = BABYLON.MeshBuilder.CreateSphere(name, { diameter: size }, scene);
  const mat = new BABYLON.StandardMaterial(name + "_mat", scene);
  mat.diffuseColor = color; p.material = mat;

  let angle = Math.random() * Math.PI * 2;
  scene.registerBeforeRender(() => {
    angle += speed * timeFactor;
    p.position.x = Math.cos(angle) * dist;
    p.position.z = Math.sin(angle) * dist;
  });

  const label = BABYLON.MeshBuilder.CreatePlane(name + "_label", { size: 8 }, scene);
  label.parent = p; label.position.y = size + 2;
  const labelTex = BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(label);
  const text = new BABYLON.GUI.TextBlock();
  text.text = name; text.color = "white"; text.fontSize = 24;
  labelTex.addControl(text);

  moons.forEach((moon, i) => {
    const m = BABYLON.MeshBuilder.CreateSphere(`${name}_moon_${i}`, { diameter: moon.size }, scene);
    const mMat = new BABYLON.StandardMaterial(`${name}_moonMat_${i}`, scene);
    mMat.diffuseColor = moon.color; m.material = mMat;
    let mAngle = Math.random() * Math.PI * 2;
    scene.registerBeforeRender(() => {
      mAngle += moon.speed * timeFactor;
      m.position.x = p.position.x + Math.cos(mAngle) * moon.distance;
      m.position.z = p.position.z + Math.sin(mAngle) * moon.distance;
    });
  });

  p.actionManager = new BABYLON.ActionManager(scene);
  p.actionManager.registerAction(new BABYLON.ExecuteCodeAction(
    BABYLON.ActionManager.OnPickTrigger, () => showPlanetInfo(name)
  ));

  return p;
}
</script>
<script>
const planets = [
  {
    name: "Mercury",
    size: 1.5,
    dist: 58,
    speed: 0.0047,
    color: BABYLON.Color3.Gray(),
    moons: []
  },
  {
    name: "Venus",
    size: 2.2,
    dist: 108,
    speed: 0.0035,
    color: new BABYLON.Color3(1.0, 0.85, 0.6),
    moons: []
  },
  {
    name: "Earth",
    size: 2.5,
    dist: 150,
    speed: 0.003,
    color: new BABYLON.Color3(0.3, 0.6, 1),
    moons: [
      { size: 0.7, distance: 5, speed: 0.03, color: BABYLON.Color3.White() }
    ]
  },
  {
    name: "Mars",
    size: 2.0,
    dist: 228,
    speed: 0.0024,
    color: new BABYLON.Color3(0.9, 0.4, 0.3),
    moons: [
      { size: 0.4, distance: 4, speed: 0.035, color: BABYLON.Color3.Gray() },
      { size: 0.4, distance: 6, speed: 0.028, color: BABYLON.Color3.Gray() }
    ]
  },
  {
    name: "Jupiter",
    size: 6.0,
    dist: 778,
    speed: 0.0013,
    color: new BABYLON.Color3(0.9, 0.8, 0.6),
    moons: [
      { size: 1.1, distance: 10, speed: 0.018, color: BABYLON.Color3.White() },
      { size: 1.0, distance: 13, speed: 0.015, color: BABYLON.Color3.White() },
      { size: 1.0, distance: 15, speed: 0.012, color: BABYLON.Color3.White() }
    ]
  },
  {
    name: "Saturn",
    size: 5.5,
    dist: 1430,
    speed: 0.00095,
    color: new BABYLON.Color3(1.0, 0.9, 0.5),
    moons: [
      { size: 0.9, distance: 11, speed: 0.013, color: BABYLON.Color3.Yellow() }
    ]
  },
  {
    name: "Uranus",
    size: 4.5,
    dist: 2870,
    speed: 0.00068,
    color: new BABYLON.Color3(0.6, 0.9, 1),
    moons: []
  },
  {
    name: "Neptune",
    size: 4.3,
    dist: 4495,
    speed: 0.00054,
    color: new BABYLON.Color3(0.3, 0.5, 1),
    moons: []
  },

  // 🛰️ Dwarf Planets
  {
    name: "Pluto",
    size: 1.1,
    dist: 5900,
    speed: 0.00047,
    color: new BABYLON.Color3(0.8, 0.8, 1),
    moons: []
  },
  {
    name: "Ceres",
    size: 0.9,
    dist: 413,
    speed: 0.0015,
    color: new BABYLON.Color3(0.9, 0.9, 0.9),
    moons: []
  },
  {
    name: "Eris",
    size: 1.0,
    dist: 6700,
    speed: 0.00041,
    color: new BABYLON.Color3(1.0, 1.0, 0.9),
    moons: []
  }
];

const orbitLines = [];
planets.forEach(p => {
  createPlanet(p.name, p.size, p.dist, p.speed, p.color, p.moons);
  const points = [];
  for (let i = 0; i <= 360; i++) {
    const rad = BABYLON.Tools.ToRadians(i);
    points.push(new BABYLON.Vector3(Math.cos(rad) * p.dist, 0, Math.sin(rad) * p.dist));
  }
  const orbit = BABYLON.MeshBuilder.CreateLines(`${p.name}_orbit`, { points }, scene);
  orbit.color = BABYLON.Color3.White(); orbit.alpha = 0.04;
  orbitLines.push(orbit);
});
</script>
<script>
for (let i = 0; i < 400; i++) {
  const dist = 400 + Math.random() * 200;
  const size = 0.2 + Math.random() * 0.3;
  const theta = Math.random() * Math.PI * 2;
  const a = BABYLON.MeshBuilder.CreateSphere("asteroid" + i, { diameter: size }, scene);
  const mat = new BABYLON.StandardMaterial("asteroidMat" + i, scene);
  mat.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.5); a.material = mat;

  scene.registerBeforeRender(() => {
    const t = theta + engine.getDeltaTime() * 0.0000018 * i;
    a.position.x = Math.cos(t) * dist;
    a.position.z = Math.sin(t) * dist;
    a.position.y = Math.sin(i * 0.008) * 1.5;
  });
}
</script>
<script>
const constellations = {
  Orion: [ new BABYLON.Vector3(-80, 40, 60), new BABYLON.Vector3(-70, 42, 55), new BABYLON.Vector3(-60, 41, 50) ],
  UrsaMajor: [ new BABYLON.Vector3(200, 90, -400), new BABYLON.Vector3(220, 92, -390), new BABYLON.Vector3(240, 94, -380) ]
};
const constellationLines = [];

Object.entries(constellations).forEach(([name, stars]) => {
  stars.forEach((pos, i) => {
    const star = BABYLON.MeshBuilder.CreateSphere(`${name}_star_${i}`, { diameter: 2 }, scene);
    star.position = pos;
    const mat = new BABYLON.StandardMaterial(`${name}_mat_${i}`, scene);
    mat.emissiveColor = BABYLON.Color3.White(); star.material = mat;
    if (i < stars.length - 1) {
      const line = BABYLON.MeshBuilder.CreateLines(`${name}_line_${i}`, {
        points: [stars[i], stars[i + 1]]
      }, scene);
      line.color = new BABYLON.Color3(0.5, 0.8, 1);
      line.alpha = 0.6;
      constellationLines.push(line);
    }
  });
});
</script>
<script>
const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

// Info panel setup
const infoPanel = new BABYLON.GUI.Rectangle();
infoPanel.width = "300px";
infoPanel.background = "rgba(0,0,0,0.75)";
infoPanel.cornerRadius = 10;
infoPanel.thickness = 0;
infoPanel.isVisible = false;
infoPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
infoPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;

const infoStack = new BABYLON.GUI.StackPanel();
infoPanel.addControl(infoStack);

const planetTitle = new BABYLON.GUI.TextBlock();
planetTitle.fontSize = 20;
planetTitle.color = "white";
infoStack.addControl(planetTitle);

const planetFact = new BABYLON.GUI.TextBlock();
planetFact.fontSize = 16;
planetFact.color = "#ccc";
planetFact.textWrapping = true;
infoStack.addControl(planetFact);

const planetLink = new BABYLON.GUI.TextBlock();
planetLink.fontSize = 14;
planetLink.color = "#80BFFF";
planetLink.textWrapping = true;
planetLink.onPointerClickObservable.add(() => {
  window.open(planetLink.text, "_blank");
});
infoStack.addControl(planetLink);

gui.addControl(infoPanel);

// Display info when a planet is clicked
function showPlanetInfo(name) {
  const facts = {
    Mercury: { text: "Closest to the Sun.", link: "https://solarsystem.nasa.gov/planets/mercury/overview/" },
    Venus:   { text: "Thick atmosphere, hottest planet.", link: "https://solarsystem.nasa.gov/planets/venus/overview/" },
    Earth:   { text: "Our home. Supports life.", link: "https://solarsystem.nasa.gov/planets/earth/overview/" },
    Mars:    { text: "Cold desert world.", link: "https://solarsystem.nasa.gov/planets/mars/overview/" },
    Jupiter: { text: "Gas giant, Great Red Spot.", link: "https://solarsystem.nasa.gov/planets/jupiter/overview/" },
    Saturn:  { text: "Known for its rings.", link: "https://solarsystem.nasa.gov/planets/saturn/overview/" },
    Uranus:  { text: "Icy, rotates on its side.", link: "https://solarsystem.nasa.gov/planets/uranus/overview/" },
    Neptune: { text: "Windswept and icy.", link: "https://solarsystem.nasa.gov/planets/neptune/overview/" },
    Pluto:   { text: "Dwarf with moons.", link: "https://solarsystem.nasa.gov/planets/dwarf-planets/pluto/overview/" },
    Ceres:   { text: "Dwarf in the asteroid belt.", link: "https://solarsystem.nasa.gov/planets/dwarf-planets/ceres/overview/" },
    Eris:    { text: "Highly reflective, distant dwarf.", link: "https://solarsystem.nasa.gov/planets/dwarf-planets/eris/overview/" }
  };
  const data = facts[name];
  if (data) {
    planetTitle.text = name;
    planetFact.text = data.text;
    planetLink.text = data.link;
    infoPanel.isVisible = true;

    const target = scene.getMeshByName(name);
    if (target) {
      camera.setTarget(target.position);
      const anim = new BABYLON.Animation("zoom", "radius", 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT);
      anim.setKeys([
        { frame: 0, value: camera.radius },
        { frame: 15, value: target.scaling.x * 40 + 100 }
      ]);
      camera.animations = [anim];
      scene.beginAnimation(camera, 0, 15, false);
    }
  }
}
</script>
<script>
// Left-side GUI toggle panel
const menuPanel = new BABYLON.GUI.Rectangle();
menuPanel.width = "220px";
menuPanel.background = "rgba(20,20,20,0.85)";
menuPanel.cornerRadius = 8;
menuPanel.thickness = 0;
menuPanel.paddingTop = "10px";
menuPanel.paddingLeft = "10px";
menuPanel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
menuPanel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
menuPanel.isVisible = false;
gui.addControl(menuPanel);

const menuStack = new BABYLON.GUI.StackPanel();
menuPanel.addControl(menuStack);

function addButton(label, callback) {
  const btn = BABYLON.GUI.Button.CreateSimpleButton(label, label);
  btn.height = "30px";
  btn.color = "lightgreen";
  btn.background = "transparent";
  btn.onPointerClickObservable.add(callback);
  menuStack.addControl(btn);
}

// GUI toggle state
let constellationsShown = true;
let orbitsShown = true;
let asteroidBeltShown = true;
let performanceMode = false;

addButton("Pause", () => timeFactor = 0);
addButton("1x Speed", () => timeFactor = 1);
addButton("10x Speed", () => timeFactor = 10);

addButton("Toggle Orbit Lines", () => {
  orbitsShown = !orbitsShown;
  orbitLines.forEach(line => line.setEnabled(orbitsShown));
});

addButton("Toggle Constellations", () => {
  constellationsShown = !constellationsShown;
  constellationLines.forEach(line => line.setEnabled(constellationsShown));
});

addButton("Toggle Asteroids", () => {
  asteroidBeltShown = !asteroidBeltShown;
  scene.meshes
    .filter(m => m.name.startsWith("asteroid"))
    .forEach(m => m.setEnabled(asteroidBeltShown));
});

addButton("Toggle Performance Mode", () => {
  performanceMode = !performanceMode;
  glowLayer.isEnabled = !performanceMode;
  starfield.isEnabled = !performanceMode;
});

// ☰ Button to toggle panel
const menuToggle = BABYLON.GUI.Button.CreateSimpleButton("toggle", "☰");
menuToggle.width = "40px";
menuToggle.height = "40px";
menuToggle.color = "white";
menuToggle.background = "rgba(0,0,0,0.6)";
menuToggle.cornerRadius = 6;
menuToggle.fontSize = 24;
menuToggle.paddingTop = "10px";
menuToggle.paddingLeft = "10px";
menuToggle.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
menuToggle.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
menuToggle.onPointerClickObservable.add(() => {
  menuPanel.isVisible = !menuPanel.isVisible;
});
gui.addControl(menuToggle);
</script>
<script>
// Keyboard movement
const moveKeys = { forward: false, back: false, left: false, right: false };
scene.onKeyboardObservable.add(kb => {
  const isDown = kb.type === BABYLON.KeyboardEventTypes.KEYDOWN;
  switch (kb.event.key.toLowerCase()) {
    case "w":
    case "arrowup": moveKeys.forward = isDown; break;
    case "s":
    case "arrowdown": moveKeys.back = isDown; break;
    case "a":
    case "arrowleft": moveKeys.left = isDown; break;
    case "d":
    case "arrowright": moveKeys.right = isDown; break;
  }
});
window.addEventListener("keydown", e => {
  if (e.key.toLowerCase() === "z") camera.setTarget(BABYLON.Vector3.Zero());
  if (e.key.toLowerCase() === "x") camera.radius = Math.max(camera.lowerRadiusLimit + 10, camera.radius * 0.9);
  if (e.key.toLowerCase() === "f") document.fullscreenElement
    ? document.exitFullscreen()
    : document.documentElement.requestFullscreen();
});

engine.runRenderLoop(() => {
  const speed = 5;
  const dir = new BABYLON.Vector3(
    (moveKeys.right ? 1 : 0) - (moveKeys.left ? 1 : 0),
    0,
    (moveKeys.back ? 1 : 0) - (moveKeys.forward ? 1 : 0)
  );
  if (!dir.equals(BABYLON.Vector3.Zero())) {
    const transformed = BABYLON.Vector3.TransformCoordinates(dir, BABYLON.Matrix.RotationY(camera.alpha));
    camera.target.addInPlace(transformed.scale(speed));
  }
  scene.render();
});
window.addEventListener("resize", () => engine.resize());

// Splash screen fade-out
window.addEventListener("DOMContentLoaded", () => {
  engine.resize();
  setTimeout(() => {
    const splash = document.getElementById("splash-screen");
    if (splash) {
      splash.style.transition = "opacity 1s ease";
      splash.style.opacity = 0;
      setTimeout(() => splash.remove(), 1000);
    }
  }, 1000);
});

// Register service worker (PWA support)
if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("sw.js")
    .then(() => console.log("✅ Service Worker registered"))
    .catch(err => console.error("🛑 Service Worker registration failed:", err));
}
</script>
</body>
</html>
