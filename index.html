<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar System Observatory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="favicon.ico" />
  <meta name="theme-color" content="#000000" />
  <style>
    html, body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      background: black;
      font-family: 'Segoe UI', sans-serif;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    #splash-screen {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background-color: black;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #splash-screen img {
      max-width: 80%;
      opacity: 0.85;
    }
  </style>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <div id="splash-screen">
    <img src="splash-loading-screen.png" alt="Loading..." />
  </div>
  <canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color3.Black();

const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.2, 2500, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 20;
camera.upperRadiusLimit = 10000;

const light = new BABYLON.PointLight("SunLight", BABYLON.Vector3.Zero(), scene);
light.intensity = 2.5;

new BABYLON.GlowLayer("glow", scene);
new BABYLON.Layer("starfield", "8k_stars_milky_way.jpg", scene, true);

let timeFactor = 1;
let followPlanet = null;
</script>
<script>
const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

const panel = new BABYLON.GUI.Rectangle();
panel.width = "250px";
panel.background = "rgba(20,20,20,0.85)";
panel.cornerRadius = 8;
panel.thickness = 0;
panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
gui.addControl(panel);

const stack = new BABYLON.GUI.StackPanel();
panel.addControl(stack);

function addButton(label, callback) {
  const btn = BABYLON.GUI.Button.CreateSimpleButton("btn_" + label, label);
  btn.height = "30px";
  btn.width = "100%";
  btn.color = "lightgreen";
  btn.background = "transparent";
  btn.onPointerClickObservable.add(callback);
  stack.addControl(btn);
}
</script>
<script>
const planetsData = [
  { name: "Earth", distance: 160, speed: 2.98, size: 6, color: new BABYLON.Color3(0.4, 0.6, 1), clouds: true, terrain: false, atmosphere: true },
  { name: "Mars", distance: 210, speed: 2.4, size: 5, color: new BABYLON.Color3(1, 0.4, 0.3), clouds: false, terrain: true, atmosphere: true },
  { name: "Moon", distance: 218, speed: 3.1, size: 1.5, color: new BABYLON.Color3(0.8, 0.8, 0.8), clouds: false, terrain: true, atmosphere: false },
  { name: "Jupiter", distance: 280, speed: 1.3, size: 12, color: new BABYLON.Color3(0.8, 0.6, 0.4), atmosphere: true },
  { name: "Venus", distance: 120, speed: 3.5, size: 5.5, color: new BABYLON.Color3(0.9, 0.7, 0.3), atmosphere: true }
];

planetsData.forEach(p => {
  const planet = BABYLON.MeshBuilder.CreateSphere(p.name, { diameter: p.size }, scene);
  const mat = new BABYLON.StandardMaterial(`${p.name}_mat`, scene);
  mat.diffuseColor = p.color;
  planet.material = mat;

  if (p.terrain) {
    const heightMap = new BABYLON.StandardMaterial(`${p.name}_heightMat`, scene);
    heightMap.diffuseTexture = new BABYLON.Texture(`${p.name.toLowerCase()}_map.jpg`, scene);
    heightMap.bumpTexture = new BABYLON.Texture(`${p.name.toLowerCase()}_bump.jpg`, scene);
    heightMap.specularColor = BABYLON.Color3.Black();
    planet.material = heightMap;
  }

  if (p.atmosphere) {
    const glow = BABYLON.MeshBuilder.CreateSphere(`${p.name}_atm`, { diameter: p.size * 1.03 }, scene);
    const atmMat = new BABYLON.StandardMaterial(`${p.name}_atmMat`, scene);
    atmMat.emissiveColor = new BABYLON.Color3(0.1, 0.4, 1);
    atmMat.alpha = 0.2;
    glow.material = atmMat;
    glow.parent = planet;
  }

  if (p.clouds) {
    const clouds = BABYLON.MeshBuilder.CreateSphere(`${p.name}_clouds`, { diameter: p.size * 1.01, segments: 32 }, scene);
    const cloudMat = new BABYLON.StandardMaterial(`${p.name}_cloudMat`, scene);
    cloudMat.diffuseTexture = new BABYLON.Texture("earth_clouds_alpha.png", scene);
    cloudMat.opacityTexture = cloudMat.diffuseTexture;
    cloudMat.emissiveColor = new BABYLON.Color3.White();
    cloudMat.alpha = 0.8;
    cloudMat.backFaceCulling = false;
    clouds.material = cloudMat;
    clouds.parent = planet;

    scene.registerBeforeRender(() => {
      clouds.rotation.y += 0.0005 * timeFactor;
    });
  }

  scene.registerBeforeRender(() => {
    const t = performance.now() * 0.00001 * p.speed * timeFactor;
    planet.position.x = Math.cos(t) * p.distance;
    planet.position.z = Math.sin(t) * p.distance;
  });
});
</script>
<script>
const sun = BABYLON.MeshBuilder.CreateSphere("Sun", { diameter: 30 }, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveColor = new BABYLON.Color3(1, 0.8, 0.1);
sun.material = sunMat;

// Solar Wind
const solarWindSystem = new BABYLON.ParticleSystem("solarWind", 1000, scene);
solarWindSystem.particleTexture = new BABYLON.Texture("flare.png", scene);
solarWindSystem.emitter = sun;
solarWindSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0);
solarWindSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0);
solarWindSystem.color1 = new BABYLON.Color4(1, 1, 1, 1);
solarWindSystem.color2 = new BABYLON.Color4(1, 0.8, 0, 1);
solarWindSystem.minSize = 0.2;
solarWindSystem.maxSize = 0.5;
solarWindSystem.emitRate = 200;
solarWindSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
solarWindSystem.gravity = new BABYLON.Vector3(0, 0, 0);
solarWindSystem.direction1 = new BABYLON.Vector3(-1, 0, 0);
solarWindSystem.direction2 = new BABYLON.Vector3(1, 0, 0);
solarWindSystem.minLifeTime = 2;
solarWindSystem.maxLifeTime = 3;
solarWindSystem.start();

// Flares (Simple Pulsing Arc)
setInterval(() => {
  const flare = BABYLON.MeshBuilder.CreateTorus("flare", {
    diameter: 36,
    thickness: 0.5,
    tessellation: 60,
    arc: 0.3
  }, scene);
  const fmat = new BABYLON.StandardMaterial("flareMat", scene);
  fmat.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
  flare.material = fmat;
  flare.rotation.y = Math.random() * Math.PI * 2;
  flare.rotation.x = Math.PI / 2;
  flare.parent = sun;

  setTimeout(() => flare.dispose(), 1500);
}, 15000);
</script>
<script>
// Create a subtle dip mesh to visualize solar gravity
const gravityWell = BABYLON.MeshBuilder.CreateGround("gravityWell", {
  width: 300,
  height: 300,
  subdivisions: 100
}, scene);

gravityWell.position.y = -20;
gravityWell.position.x = gravityWell.position.z = 0;

const wellMat = new BABYLON.StandardMaterial("gravityWellMat", scene);
wellMat.wireframe = true;
wellMat.emissiveColor = new BABYLON.Color3(0.2, 0.5, 1);
gravityWell.material = wellMat;

// Apply deformation toward center
const positions = gravityWell.getVerticesData(BABYLON.VertexBuffer.PositionKind);
for (let i = 0; i < positions.length; i += 3) {
  const x = positions[i];
  const z = positions[i + 2];
  const dist = Math.sqrt(x*x + z*z);
  positions[i + 1] = -10 / (1 + dist * 0.05); // Y value (gravity dip)
}
gravityWell.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
</script>
<script>
const constellationLines = new BABYLON.MeshBuilder.CreateLines("orion", {
  points: [
    new BABYLON.Vector3(400, 100, 300),
    new BABYLON.Vector3(410, 90, 310),
    new BABYLON.Vector3(420, 80, 300)
  ]
}, scene);
constellationLines.color = new BABYLON.Color3(1, 1, 1);
constellationLines.isVisible = false;

addButton("🌌 Toggle Constellations", () => {
  constellationLines.isVisible = !constellationLines.isVisible;
});
</script>
<script>
const slider = new BABYLON.GUI.Slider();
slider.minimum = -500;
slider.maximum = 500;
slider.value = 0;
slider.height = "20px";
slider.width = "150px";
slider.color = "orange";
slider.background = "gray";
slider.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
slider.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
slider.top = "20px";

slider.onValueChangedObservable.add(val => {
  timeFactor = val;
});

gui.addControl(slider);
</script>
<script>
const iss = BABYLON.MeshBuilder.CreateBox("ISS", { size: 1.5 }, scene);
const issMat = new BABYLON.StandardMaterial("issMat", scene);
issMat.emissiveColor = new BABYLON.Color3(0.8, 1, 1);
iss.material = issMat;

async function fetchISSPosition() {
  try {
    const response = await fetch("https://api.wheretheiss.at/v1/satellites/25544");
    const data = await response.json();

    const earthRadius = 160; // Match Earth position distance
    const lat = BABYLON.Tools.ToRadians(data.latitude);
    const lon = BABYLON.Tools.ToRadians(data.longitude);

    iss.position.x = Math.cos(lat) * Math.cos(lon) * earthRadius;
    iss.position.z = Math.cos(lat) * Math.sin(lon) * earthRadius;
    iss.position.y = Math.sin(lat) * earthRadius;
  } catch (err) {
    console.warn("Could not fetch ISS position", err);
  }
}
setInterval(fetchISSPosition, 5000);
</script>
<script>
function annotatePlanet(name, text) {
  const rect = new BABYLON.GUI.Rectangle("anno_" + name);
  rect.width = "200px";
  rect.height = "auto";
  rect.cornerRadius = 10;
  rect.background = "rgba(0,0,0,0.7)";
  rect.thickness = 1;
  rect.color = "white";

  const label = new BABYLON.GUI.TextBlock();
  label.text = text;
  label.color = "#A0E0FF";
  label.fontSize = 14;
  label.textWrapping = true;
  rect.addControl(label);

  gui.addControl(rect);

  scene.registerBeforeRender(() => {
    const mesh = scene.getMeshByName(name);
    if (mesh) {
      const pos = BABYLON.Vector3.Project(mesh.position, BABYLON.Matrix.Identity(), scene.getTransformMatrix(), camera.viewport.toGlobal(engine.getRenderWidth(), engine.getRenderHeight()));
      rect.left = pos.x - engine.getRenderWidth() / 2 + "px";
      rect.top = pos.y - engine.getRenderHeight() / 2 + "px";
    }
  });
}

annotatePlanet("Mars", "🪐 Mars:\n• Avg Temp: -63°C\n• Axial Tilt: 25°\n• 2 moons\n• Known for Olympus Mons");
</script>
<script>
window.addEventListener("DOMContentLoaded", () => {
  const t = localStorage.getItem("cameraTarget");
  const r = localStorage.getItem("cameraRadius");
  if (t) camera.setTarget(BABYLON.Vector3.FromArray(JSON.parse(t)));
  if (r) camera.radius = parseFloat(r);

  setTimeout(() => {
    const splash = document.getElementById("splash-screen");
    if (splash) {
      splash.style.transition = "opacity 1s ease";
      splash.style.opacity = 0;
      setTimeout(() => splash.remove(), 1000);
    }
  }, 1000);
});

window.addEventListener("beforeunload", () => {
  localStorage.setItem("cameraTarget", JSON.stringify(camera.target));
  localStorage.setItem("cameraRadius", camera.radius);
});

engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());

if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("sw.js")
    .then(() => console.log("✅ Service Worker registered"))
    .catch(err => console.warn("Service Worker error:", err));
}
</script>
</body>
</html>
