<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar System Observatory</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="favicon.ico" />
  <meta name="theme-color" content="#000000" />

  <style>
    html, body { margin: 0; overflow: hidden; height: 100%; background: black; }
    #renderCanvas { width: 100%; height: 100%; display: block; }
    #splash-screen {
      position: absolute;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      background-color: black;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #splash-screen img {
      max-width: 80%;
      opacity: 0.85;
    }
  </style>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
  <div id="splash-screen">
    <img src="splash-loading-screen.png" alt="Loading..." />
  </div>
  <canvas id="renderCanvas"></canvas>
<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);
let scene = new BABYLON.Scene(engine);

const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.3, 300, BABYLON.Vector3.Zero(), scene);
camera.attachControl(canvas, true);
camera.lowerRadiusLimit = 30;
camera.upperRadiusLimit = 12000;

const light = new BABYLON.PointLight("sunLight", BABYLON.Vector3.Zero(), scene);
light.intensity = 2.4;

new BABYLON.GlowLayer("glow", scene);
new BABYLON.Layer("backgroundStars", "8k_stars_milky_way.jpg", scene, true);

let timeFactor = 1;
</script>
<script>
const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI", true, scene);

const panel = new BABYLON.GUI.Rectangle();
panel.width = "260px";
panel.background = "rgba(20,20,20,0.85)";
panel.cornerRadius = 8;
panel.thickness = 0;
panel.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
panel.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
panel.left = "10px"; panel.top = "10px";
gui.addControl(panel);

const stack = new BABYLON.GUI.StackPanel();
stack.paddingTop = "10px";
panel.addControl(stack);

function addButton(label, callback) {
  const btn = BABYLON.GUI.Button.CreateSimpleButton("btn_" + label, label);
  btn.height = "30px";
  btn.width = "95%";
  btn.color = "lightgreen";
  btn.background = "transparent";
  btn.onPointerClickObservable.add(callback);
  stack.addControl(btn);
}
</script>
<script>
function createPlanet({ name, size, color, distance, speed, atmosphere, terrain, clouds }) {
  const sphere = BABYLON.MeshBuilder.CreateSphere(name, { diameter: size, segments: 32 }, scene);
  const mat = new BABYLON.StandardMaterial(`${name}_mat`, scene);
  mat.diffuseColor = color;

  if (terrain) {
    mat.diffuseTexture = new BABYLON.Texture("https://planetpixelemporium.com/images/marscolor.jpg", scene);
    mat.bumpTexture = new BABYLON.Texture("https://planetpixelemporium.com/images/marsbump.jpg", scene);
    mat.specularColor = BABYLON.Color3.Black();
  }

  sphere.material = mat;

  if (atmosphere) {
    const atm = BABYLON.MeshBuilder.CreateSphere(`${name}_atm`, { diameter: size * 1.03 }, scene);
    const atmMat = new BABYLON.StandardMaterial(`${name}_atmMat`, scene);
    atmMat.emissiveColor = new BABYLON.Color3(0.2, 0.5, 1);
    atmMat.alpha = 0.2;
    atm.material = atmMat;
    atm.parent = sphere;
  }

  if (clouds) {
    const cloud = BABYLON.MeshBuilder.CreateSphere(`${name}_clouds`, { diameter: size * 1.01, segments: 32 }, scene);
    const cloudMat = new BABYLON.StandardMaterial(`${name}_cloudMat`, scene);
    cloudMat.diffuseTexture = new BABYLON.Texture("https://planetpixelemporium.com/images/clouds_512.png", scene);
    cloudMat.opacityTexture = cloudMat.diffuseTexture;
    cloudMat.emissiveColor = BABYLON.Color3.White();
    cloudMat.alpha = 0.8;
    cloudMat.backFaceCulling = false;
    cloud.material = cloudMat;
    cloud.parent = sphere;

    scene.registerBeforeRender(() => {
      cloud.rotation.y += 0.0005 * timeFactor;
    });
  }

  scene.registerBeforeRender(() => {
    const t = performance.now() * 0.00001 * speed * timeFactor;
    sphere.position.x = Math.cos(t) * distance;
    sphere.position.z = Math.sin(t) * distance;
  });

  return sphere;
}

// Instantiate Earth and Mars
createPlanet({
  name: "Earth",
  size: 6,
  color: new BABYLON.Color3(0.4, 0.6, 1),
  distance: 160,
  speed: 2.98,
  atmosphere: true,
  terrain: false,
  clouds: true
});

createPlanet({
  name: "Mars",
  size: 5,
  color: new BABYLON.Color3(1, 0.4, 0.3),
  distance: 210,
  speed: 2.4,
  atmosphere: true,
  terrain: true,
  clouds: false
});
</script>
<script>
// 🌞 Sun Mesh
const sun = BABYLON.MeshBuilder.CreateSphere("Sun", { diameter: 32 }, scene);
const sunMat = new BABYLON.StandardMaterial("sunMat", scene);
sunMat.emissiveColor = new BABYLON.Color3(1, 0.8, 0.1);
sun.material = sunMat;
sun.position = BABYLON.Vector3.Zero();

// 🔥 Solar Wind Particle System
const solarWind = new BABYLON.ParticleSystem("solarWind", 1000, scene);
solarWind.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/flare.png", scene);
solarWind.emitter = sun;
solarWind.minEmitBox = BABYLON.Vector3.Zero();
solarWind.maxEmitBox = BABYLON.Vector3.Zero();
solarWind.color1 = new BABYLON.Color4(1, 0.9, 0.6, 1);
solarWind.color2 = new BABYLON.Color4(1, 0.5, 0.2, 1);
solarWind.minSize = 0.3;
solarWind.maxSize = 0.8;
solarWind.emitRate = 200;
solarWind.direction1 = new BABYLON.Vector3(-1, 0.3, -1);
solarWind.direction2 = new BABYLON.Vector3(1, -0.3, 1);
solarWind.minLifeTime = 2;
solarWind.maxLifeTime = 3;
solarWind.gravity = BABYLON.Vector3.Zero();
solarWind.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
solarWind.start();

// ⚡ Flare Bursts (Torus)
setInterval(() => {
  const flare = BABYLON.MeshBuilder.CreateTorus("solarFlare", {
    diameter: 38,
    thickness: 0.5,
    tessellation: 48,
    arc: 0.35
  }, scene);

  const flareMat = new BABYLON.StandardMaterial("flareMat", scene);
  flareMat.emissiveColor = new BABYLON.Color3(1, 0.5, 0);
  flare.material = flareMat;

  flare.rotation.x = Math.PI / 2;
  flare.rotation.y = Math.random() * Math.PI * 2;
  flare.parent = sun;

  setTimeout(() => flare.dispose(), 1800);
}, 15000);
</script>
<script>
const iss = BABYLON.MeshBuilder.CreateSphere("ISS", { diameter: 1.5 }, scene);
const issMat = new BABYLON.StandardMaterial("issMat", scene);
issMat.emissiveColor = new BABYLON.Color3(0.7, 1, 1);
iss.material = issMat;

function updateISS() {
  fetch("https://api.wheretheiss.at/v1/satellites/25544")
    .then(res => res.json())
    .then(data => {
      const radius = 160; // Earth's orbital distance
      const lat = BABYLON.Tools.ToRadians(data.latitude);
      const lon = BABYLON.Tools.ToRadians(data.longitude);
      iss.position.x = Math.cos(lat) * Math.cos(lon) * radius;
      iss.position.z = Math.cos(lat) * Math.sin(lon) * radius;
      iss.position.y = Math.sin(lat) * radius;
    })
    .catch(err => console.warn("ISS fetch failed:", err));
}

setInterval(updateISS, 5000);
</script>
<script>
let eclipseActive = false;
let eclipseOverlay;

addButton("☀️ Toggle Eclipses", () => {
  if (!eclipseOverlay) {
    eclipseOverlay = BABYLON.MeshBuilder.CreateDisc("eclipseShadow", { radius: 10 }, scene);
    eclipseOverlay.position = new BABYLON.Vector3(0, 0.1, -160); // Overlay Earth approx
    const mat = new BABYLON.StandardMaterial("eclipseMat", scene);
    mat.diffuseColor = new BABYLON.Color3(0, 0, 0);
    mat.alpha = 0.5;
    eclipseOverlay.material = mat;
    eclipseOverlay.isVisible = false;
  }
  eclipseActive = !eclipseActive;
  eclipseOverlay.isVisible = eclipseActive;
});
</script>
<script>
// Meteor trail bursts every 30 seconds
setInterval(() => {
  const system = new BABYLON.ParticleSystem("meteor", 200, scene);
  system.particleTexture = new BABYLON.Texture("https://assets.babylonjs.com/textures/flare.png", scene);
  system.emitter = new BABYLON.Vector3(0, 300, 0);
  system.minEmitBox = new BABYLON.Vector3(-200, 0, -200);
  system.maxEmitBox = new BABYLON.Vector3(200, 0, 200);
  system.direction1 = new BABYLON.Vector3(0, -1, 0);
  system.direction2 = new BABYLON.Vector3(0.2, -1, 0.2);
  system.emitRate = 400;
  system.minLifeTime = 0.6;
  system.maxLifeTime = 1;
  system.minSize = 0.4;
  system.maxSize = 0.8;
  system.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
  system.color1 = new BABYLON.Color4(1, 0.8, 0.5, 1);
  system.gravity = new BABYLON.Vector3(0, -9.8, 0);
  system.targetStopDuration = 0.8;
  system.start();
}, 30000);

// Lagrange Point Orbs
let lagrangeShown = false;
const lagrangePoints = [];

["L1", "L2", "L3", "L4", "L5"].forEach((label, i) => {
  const orb = BABYLON.MeshBuilder.CreateSphere(label, { diameter: 1.2 }, scene);
  orb.material = new BABYLON.StandardMaterial(label + "_mat", scene);
  orb.material.emissiveColor = new BABYLON.Color3(0.6, 0.9, 1);
  orb.position = new BABYLON.Vector3(160 + (i * 20) * (i % 2 === 0 ? 1 : -1), 0, -30 + i * 10);
  orb.setEnabled(false);
  lagrangePoints.push(orb);
});

addButton("⚖️ Lagrange Points", () => {
  lagrangeShown = !lagrangeShown;
  lagrangePoints.forEach(p => p.setEnabled(lagrangeShown));
});
</script>
<script>
let musicOn = false;
let music;

addButton("🎧 Toggle Music", () => {
  if (!music) {
    music = new Audio("https://cdn.pixabay.com/audio/2022/03/29/audio_a7cbe0ac5c.mp3");
    music.loop = true;
    music.volume = 0.3;
  }
  if (musicOn) {
    music.pause();
  } else {
    music.play();
  }
  musicOn = !musicOn;
});
</script>
<script>
// Scene transition
let periodicScene = null;
let inPeriodicMode = false;

addButton("🧪 Periodic Table", () => {
  inPeriodicMode = true;
  periodicScene = new BABYLON.Scene(engine);

  const cam = new BABYLON.ArcRotateCamera("cam", Math.PI / 2, Math.PI / 2.3, 50, BABYLON.Vector3.Zero(), periodicScene);
  cam.attachControl(canvas, true);

  const light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 1, 0), periodicScene);
  periodicScene.clearColor = new BABYLON.Color3(0, 0, 0);

  const table = [];
  for (let i = 0; i < 118; i++) {
    const tile = BABYLON.MeshBuilder.CreateBox("E" + (i + 1), { size: 2 }, periodicScene);
    const mat = new BABYLON.StandardMaterial("mat" + i, periodicScene);
    mat.emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
    tile.material = mat;
    tile.position.x = (i % 18) * 2.5 - 20;
    tile.position.y = Math.floor(i / 18) * -2.5 + 10;
    table.push(tile);
  }

  addButton("🚀 Back to Solar System", () => {
    inPeriodicMode = false;
  });
});
</script>
<script>
window.addEventListener("DOMContentLoaded", () => {
  const t = localStorage.getItem("cameraTarget");
  const r = localStorage.getItem("cameraRadius");
  if (t) camera.setTarget(BABYLON.Vector3.FromArray(JSON.parse(t)));
  if (r) camera.radius = parseFloat(r);

  const splash = document.getElementById("splash-screen");
  if (splash) {
    splash.style.transition = "opacity 1s ease";
    splash.style.opacity = 0;
    setTimeout(() => splash.remove(), 1000);
  }
});

window.addEventListener("beforeunload", () => {
  localStorage.setItem("cameraTarget", JSON.stringify(camera.target));
  localStorage.setItem("cameraRadius", camera.radius);
});

engine.runRenderLoop(() => {
  if (inPeriodicMode && periodicScene) {
    periodicScene.render();
  } else {
    scene.render();
  }
});

window.addEventListener("resize", () => engine.resize());

if ("serviceWorker" in navigator) {
  navigator.serviceWorker.register("sw.js")
    .then(() => console.log("✅ Service Worker registered"))
    .catch(err => console.warn("SW Error:", err));
});
</script>
</body>
</html>
